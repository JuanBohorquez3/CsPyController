"""
author = 'Martin Lichtman'
created = 2013-04-02
modified >= 2014-04-21

cs_GUI.enaml

A GUI for the Cs experiment controller, written using the enaml toolkit for python.
"""

from __future__ import division
import logging
logger = logging.getLogger(__name__)

from cs_errors import PauseError

from enaml.layout.api import vbox, hbox, align, horizontal, vertical, spacer, grid
from enaml.widgets.api import (MainWindow, MenuBar, Menu, Action,
                                Notebook, Page, Container, GroupBox, 
                                Form, Label, CheckBox, SpinBox, PushButton, MPLCanvas,
                                MultilineField, ProgressBar, ScrollArea, Separator,
                                FileDialog,Window, StatusBar, StatusItem,
                                Stack, StackItem, ComboBox
)
from enaml.core.declarative import d_
from enaml.core.include import Include
from enaml.stdlib.fields import FloatField, IntField
from enaml.core.api import Looper, Conditional
from enaml.validator import Validator
from atom.api import Member, Bool, Typed, observe, Callable
import threading, datetime, time, os, itertools
import numpy, itertools

from experiments import IndependentVariable
from instrument_property import ListProp

# redefine field so that all Fields will give tool_tips
from enaml.widgets.api import Field as OldField
enamldef Field(OldField):
    tool_tip << text

enamldef RefreshableLooper(Looper): self:
    """A Looper that sends a reference of itself to the backend controller, so it can be forcibly updated."""
    initialized::
        iterable.gui = self

class MyBoolValidator(Validator):
    experiment=Member()

    def __init__(self,experiment):
        super(MyBoolValidator,self).__init__()
        self.experiment=experiment

    def validate(self,text):
        try:
            value = self.experiment.eval_bool(text)
        except:
            return False
        return True

class MyFloatValidator(Validator):
    experiment=Member()

    def __init__(self,experiment):
        super(MyFloatValidator,self).__init__()
        self.experiment=experiment

    def validate(self,text):
        try:
            value = self.experiment.eval_float(text)
        except:
            return False
        return True

class MyEnumValidator(Validator):
    experiment=Member()
    allowedValues=Member()

    def __init__(self,experiment,allowedValues):
        super(MyEnumValidator,self).__init__()
        self.experiment=experiment
        self.allowedValues=allowedValues

    def validate(self,text):
        try:
            value = self.experiment.eval_general(text)
        #check for parsing errors
        except:
            return False
        #check if the value is one of the ones allowed by this particular Enum
        if value not in self.allowedValues:
            return False
        #if we've gotten this far, all tests have passed
        return True

#TODO: make these Fields have validation and able to process statements
enamldef MyIntField(Field):
    """This class exists to make an IntField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = int(text)

enamldef MyFloatField(Field):
    """This class exists to make a FloatField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = float(text)

enamldef MyBoolField(Field):
    """This class exists to make a BoolField (which isn't something that is available anyway),
     that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = bool(text)

enamldef IndexedStack(GroupBox): indexedStack:
    attr iterable=Typed(ListProp)
    attr viewType #=Class(StackItem)  #do we really have to declare what type? I suppose this was so that we would be okay with creating an instance
    hug_height = 'strong'
    hug_width = 'strong'

    Container: controls:
        constraints=[hbox(addButton,removeButton,combo)]
        PushButton: addButton:
            text='+'
            constraints=[width==50,height==20]
            clicked::
                iterable.add()
                combo.maximum=len(iterable)-1
                combo.value=combo.maximum
        PushButton: removeButton:
            text='-'
            constraints=[width==50,height==20]
            clicked::
                i=combo.value
                if i>=0:
                    iterable.pop(i)
                    combo.maximum=len(iterable)-1
                    if i>1:
                        combo.value=i-1
                    else:
                        combo.value=0
        # RefreshableComboBox: combo:
            # items<<[str(i)+' '+n.description for i,n in enumerate(iterable)]
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum<<len(iterable)-1
            minimum=0
    Stack: stack:
        index<<combo.value
        RefreshableLooper:
            iterable<<indexedStack.iterable
            Include:
                objects=[viewType(item=loop_item)]

def get_load_file_callback(experiment):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.load(dlg.path)
            except PauseError:
                pass
    return load_file_callback

def get_save_file_callback(experiment):
    def save_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.save(dlg.path)
            except PauseError:
                pass
    return save_file_callback

enamldef CsMenuBar(MenuBar): menuBar:
    attr experiment
    attr mainWindow
    
    Menu:
        title = '&File'
        Action:
            text = 'Load\tCtrl+L'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Choose file to load',
                    mode='open_file',
                    path=experiment.settings_path,
                    callback=get_load_file_callback(experiment),
                    ).open()
        Action:
            text = 'Save\tCtrl+S'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Save As?',
                    mode='save_file',
                    path=os.path.join(experiment.settings_path,'settings-{}.hdf5'.format(datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S'))),
                    callback=get_save_file_callback(experiment),
                    ).open()
        Action:
            text = 'Quit\tCtrl+Q'
            triggered::
                mainWindow.close()
    Menu:
        title = '&Experiment'
        Action:
            text = 'Reset and Run\tCtrl+R'
            triggered::experiment.resetAndGoThread()
        Action:
            text = 'Reset'
            triggered::experiment.resetThread()
        Action:
            text = 'Run'
            triggered::experiment.goThread()
        Menu:
            title = 'Pause...'
            Action:
                checkable = True
                text = 'After Measurement'
                checked := experiment.pauseAfterMeasurement
            Action:
                checkable = True
                text = 'After Iteration'
                checked := experiment.pauseAfterIteration
            Action:
                checkable = True
                text = 'After Error'
                checked := experiment.pauseAfterError
        Action:
            text = 'Continue\tCtrl+G'
            triggered::experiment.goThread()
        Action:
            text = 'End and Upload'
            triggered::experiment.endThread()
        Action:
            text = 'Halt\tCtrl+H'
            triggered::experiment.halt()

enamldef EvalProp(GroupBox):
    attr prop
    padding=0
    flat=True
    title<<prop.name
    constraints=[desc.width==func.width,func.width==val.width,hbox(desc,func,val),align('v_center',desc,func,val)]

    Field: desc:
        text:=prop.description
        placeholder='description'
    Field: func:
        text:=prop.function
        placeholder=prop.placeholder
        validator=prop #.validator
        #valid<<prop.valid
    Label: val:
        text<<str(prop.value)
#    CheckBox: check:
#        checked<<prop.valid
#        enabled=False
        
    
enamldef MultilineProp(GroupBox):        
    attr prop
    flat=True
    title:=prop.name
    constraints=[vbox(desc,hbox(func,val)),align('top',func,val)]
    Field: desc:
        text:=prop.description
        placeholder='description'
    MultilineField: func:
        text:=prop.function
    Label: val:
        text<<str(prop.value)

enamldef LabelBox(Container):
    attr checked #=False
    attr text #=''
    
    padding=0
    constraints=[hbox(label,box),align('v_center',label,box)]
    hug_height='strong'
    hug_width='strong'
    Label: label:
        text<<parent.text
    CheckBox: box:
        checked:=parent.checked

enamldef CheckField(Container):
    attr checked=False
    attr text=''
    attr placeholder=''
    
    constraints=[hbox(box,field),align('v_center',box,field)]
    CheckBox: box:
        checked:=parent.checked
    Field: field:
        text:=parent.text
        placeholder:=parent.placeholder

enamldef LabelField(Container):
    attr label=''
    attr text=''
    attr placeholder=''
    
    hug_height='strong'
    hug_width='strong'
    constraints=[vbox(l1,f1),l1.left==f1.left]
    Label: l1:
        text:=parent.label
    Field: f1:
        text:=parent.text
        placeholder:=parent.placeholder

#class RefreshableComboBox(ComboBox):
#    refresh = EnamlEvent

enamldef ExperimentPage(Page):
    attr experiment
    title='Experiment'

    Container:
        Form: form:
            Label:
                text="Status:"
            Label:
                text<<experiment.statusStr

            Label:
                text='Pause after iteration'
            CheckBox:
                checked:=experiment.pauseAfterIteration

            Label:
                text='Pause after measurement'
            CheckBox:
                checked:=experiment.pauseAfterMeasurement
            
            Label:
                text='Pause after error'
            CheckBox:
                checked:=experiment.pauseAfterError
            
            Label: text='Save Data?'
            CheckField:
                checked:=experiment.saveData
                text:=experiment.localDataPath
                placeholder='local data path'
            
            Label: text='Save Settings?'
            CheckBox:
                checked:=experiment.saveSettings
            
            Label: text='Save 2013 style files?'
            CheckBox:
                checked:=experiment.save2013styleFiles

            Label: text='Copy Data to Network?'
            CheckField:
                checked:=experiment.copyDataToNetwork
                text:=experiment.networkDataPath
                placeholder='network data path'

            Label: text='Experiment description suffix for filename'
            Field: text:=experiment.experimentDescriptionFilenameSuffix

            Label: text='Measurement Timeout [s]'
            FloatField: value:=experiment.measurementTimeout

            Label: text='Measurements per Iteration'
            IntField: value:=experiment.measurementsPerIteration
        
            Label: text='E-mail on error/completion?'
            CheckField:
                checked:=experiment.willSendEmail
                text:=experiment.emailAddresses
            
            Label: text='Progress'
            Label: text<<'{}%'.format(experiment.progressGUI)
            
            Label: text='Iteration'
            Label: text<<experiment.iterationStr
            
            Label: text='Measurement'
            Label: text<<experiment.measurementStr
            
            Label: text='Good Measurements'
            Label: text<<experiment.goodMeasurementsStr
            
            Label: text='Time started'
            Label: text<<experiment.timeStartedStr
            
            Label: text='Time after last measurement'
            Label: text<<experiment.currentTimeStr
            
            Label: text='Time elapsed'
            Label: text<<experiment.timeElapsedStr

            Label: text='Estimated total time'
            Label: text<<experiment.totalTimeStr

            Label: text='Estimated time remaining'
            Label: text<<experiment.timeRemainingStr

            Label: text='Estimated completion time'
            Label: text<<experiment.completionTimeStr
            
            Label: text='Notes'
            MultilineField:
                text:=experiment.notes

enamldef VariableEntry(GroupBox):
    attr indepVar

    constraints=[nameCont.width==0.5*descCont.width,descCont.width==funcCont.width,currentValueLabel.right==funcCont.right,vbox(hbox(nameCont,descCont,funcCont),valueListLabel,hbox(stepsLabel,currentValueLabel)),align('v_center',nameCont,descCont,funcCont),align('v_center',stepsLabel,currentValueLabel)]
    
    Field: nameCont:
        text:=indepVar.name
        placeholder='name'
    Field: descCont:
        text:=indepVar.description
        placeholder='description'
    Field: funcCont:
        text:=indepVar.function
        placeholder='function'
    Label: valueListLabel:
        text<<'values: '+indepVar.valueListStr
    Label: stepsLabel:
        text<<'step: '+str(indepVar.index)+' of '+str(indepVar.steps)
    Label: currentValueLabel:
        text<<'current value: '+indepVar.currentValueStr

enamldef IndependentVariablesGroupBox(GroupBox):
    attr independentVariables
    title='Independent Variables'
    
    GroupBox:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton0,removeButton0)]
        SpinBox: spin0:
            minimum=0
            maximum << independentVariables.length
        PushButton: addButton0:
            text='+'
            clicked::
                independentVariables.add_at(spin0.value)
        PushButton: removeButton0:
            text='-'
            clicked::
                independentVariables.pop(spin0.value)

    RefreshableLooper:
        iterable<<independentVariables
        VariableEntry:
            indepVar << loop_item

enamldef VariablesPage(Page): main:
    attr experiment
    title = 'Variables'
    Container:
        Container:
            constraints=[hbox(settings,report),align('top',settings,report)]
            hug_height='strong'
            hug_width='strong'

            Container: settings:
                padding=0
                hug_height='strong'
                hug_width='strong'

                PushButton: updateButton:
                    text='Update variables throughout experiment'
                    clicked::
                        experiment.evaluateAll()
                IndependentVariablesGroupBox: independent:
                    independentVariables<<experiment.independentVariables

                GroupBox: dependent:
                    title='Dependent Variables'
                    constraints=[vbox(lb1,field,variablesNotToSave)]
                    Label: lb1:
                        text='Define dependent variables using python code below.'
                    MultilineField: field:
                        constraints=[height==600]
                        text:=experiment.dependentVariablesStr
                    GroupBox: variablesNotToSave:
                        hug_height='strong'
                        title='Variables Not To Save to HDF5 (comma separated)'
                        Field:
                            text:=experiment.variablesNotToSave
                            placeholder='scipy,numpy,x'
            GroupBox: report:
                title='Report'
                hug_height='strong'
                hug_width='strong'
                constraints=[hbox(f1,lb2),align('top',f1,lb2)]

                MultilineField: f1:
                    constraints=[height==600]
                    text:=experiment.variableReportFormat
                Label: lb2:
                    text<<experiment.variableReportStr

enamldef LabViewPage(Page):
    attr LabView
    title = 'LabView'
    
    Container:
        Container:
            hug_height='strong'
            Container:
                constraints=[hbox(b1,b3,b4),b1.width==100,b3.width==100,b4.width==100]
                PushButton: b1:
                    text='open connection'
                    clicked::
                        LabView.openThread()
                PushButton: b3:
                    text='update settings'
                    clicked::
                        LabView.update()
                PushButton: b4:
                    text='close connection'
                    clicked::
                        LabView.close()

            Form:
                Label:
                    text='enable communication with LabView system?'
                CheckBox:
                    checked:=LabView.enabled
                Label:
                    text='IP address of LabView system'
                Field:
                    text:=LabView.IP
                Label:
                    text='communications port'
                IntField:
                    value:=LabView.port
                Label:
                    text='cycle experiment continuously even when not taking data?'
                CheckBox:
                    checked:=LabView.cycleContinuously
            EvalProp:
                prop<<LabView.timeout
            Form:
                Label:
                    text='connected'
                CheckBox:
                    checked:=LabView.connected
                    enabled=False
                Label: text='LabView error'
                Label: text<<str(LabView.error)
            
            GroupBox:
                title='TCP output message'
                constraints = [vbox(scroller1),(height==500)|'strong']
                hug_width='ignore'
                ScrollArea:scroller1:
                    Container:
                        hug_height='ignore'
                        hug_width='ignore'
                        Label:
                            hug_height='ignore'
                            hug_width='ignore'
                            text<<LabView.msg

            GroupBox:
                title='LabView log'
                constraints = [vbox(scroller2),(height==500)|'strong']
                hug_width='ignore'
                ScrollArea: scroller2:
                    Container:
                        hug_height='ignore'
                        hug_width='ignore'
                        Label:
                            hug_height='ignore'
                            hug_width='ignore'
                            text<<LabView.log

enamldef DOchannel(Container):
    attr channel
    attr index
    hug_height='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel.description
        placeholder='description'
    Field: activeF:
        text:=channel.active.function
        placeholder='active?'
    Label: activeL:
        text<<str(channel.active.value)

enamldef HSDIOScriptTrigger(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
        EvalProp:
            prop<<item.id
        EvalProp:
            prop<<item.source
        EvalProp:
            prop<<item.type
        EvalProp:
            prop<<item.edge
        EvalProp:
            prop<<item.level

enamldef StartTrigger(GroupBox):
    attr trigger
    title='Start Trigger'
    
    EvalProp:
        prop<<trigger.waitForStartTrigger
    EvalProp:
        prop<<trigger.source
    EvalProp:
        prop<<trigger.edge

class RefreshableMPLCanvas(MPLCanvas):
    """ An MPLCanvas that can be refreshed on command by toggling refresh.
    Requires adding a function to MPLCanvas in
    C:\Users\Saffmanlab\AppData\Local\Enthought\Canopy\User\Lib\site-packages\enaml\qt\qt_mpl_canvas.py:
        def on_action_set_refresh(self, content):
            self.refresh_mpl_widget()
    """
    
    #: Toggle this to refresh the canvas
    refresh = d_(Bool())

class RemoveEventContainer(Container):
    remove=d_(Bool())

enamldef NumpyDOchannel(Container):
    attr channel
    attr index
    attr digitalout #the DAQmxDO or HSDIO
    attr experiment

    hug_height='strong'
    hug_width='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel['description']
        placeholder='description'
    Field: activeF:
        text:=channel['function']
        placeholder='active?'
        validator<<MyBoolValidator(experiment)
        text::
            channel['value']=experiment.eval_bool(text)
            activeL.text=str(channel['value']) #must be updated manually because the channel['value'] identity does not change
            digitalout.evaluate()
    Label: activeL:
        text<<str(channel['value'])

enamldef NumpyDOchannels(GroupBox):
    attr channels
    title='channels (#, description, active?)'
    hug_height='strong'
    hug_width='strong'
    #constraints=[controls.left==dynoCont.left]
    Container: controls:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton,removeButton)]
        SpinBox: spin0:
            minimum=0
            maximum<<len(channels.array)
        PushButton: addButton:
            text='+'
            clicked::
                channels.add(spin0.value)
        PushButton: removeButton:
            text='-'
            clicked::
                channels.remove(spin0.value)
    Container: dynoCont:
        Include: dyno:
            objects<<[NumpyDOchannel(channel=x,index=i,digitalout=channels.digitalout,experiment=channels.experiment) for i,x in enumerate(channels.array)]

enamldef NumpyState(Form):
    attr state
    attr experiment
    attr waveform

    padding=0

    Field:
        constraints = [width == 100,height==20]
        #placeholder='state: None,0,1'
        text:=state['function']
        validator<<MyEnumValidator(experiment,[None,0,1])
        text::
            temp=experiment.eval_general(text)
            if temp is None:
                state['value']=5
                valueLabel.text=''
            else:
                state['value']=temp
                valueLabel.text=str(state['value']) #must be updated manually because state['value'] identity does not change
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width == 50,height==20]
        text<<('' if state['value']==5 else str(state['value']))

enamldef ChannelCombo(ComboBox):
    attr wfm
    attr channels
    attr channelList
    attr position
    
    items<<[str(i)+' '+x for i,x in enumerate(channels.array['description'])]
    index<<int(channelList[position])
    index::
        channelList[position]=numpy.uint8(index)
        wfm.updateFigure()

enamldef TransitionsLabel(Container):
    padding=0
    Label:
        constraints = [height == 20]
        text='description'
    Label:
        constraints = [height == 20]
        text='time'

enamldef DescriptionLabel(Label):
    constraints = [height == 20]
    text='description'
    
enamldef TimeLabel(Label):
    constraints = [height == 20]
    text='time'

enamldef TransitionDescription(Field):
    attr transition
    constraints = [height==20]
    placeholder = 'description'
    text:=transition['description']

enamldef TransitionTime(Form):
    attr experiment
    attr waveform
    attr transition
    
    padding=0
    
    Field:
        tool_tip << text
        status_tip << text
        constraints = [width == 100,height==20]
        placeholder='time'
        text:=transition['function']
        validator<<MyFloatValidator(experiment)
        text::
            transition['value']=experiment.eval_float(text)
            valueLabel.text='{:.6f}'.format(transition['value']) #must be updated manually because transition['value'] identity does not change
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width == 50,height==20]
        text<<'{:.6f}'.format(transition['value'])

enamldef NumpyWaveform(Container):
    attr waveform
    
    hug_height='strong'
    hug_width='ignore'
    constraints=[vbox(plotcontrols,details),align('left',plotcontrols,details)]
    
    Container: plotcontrols:
        hug_width='strong'
        hug_height='strong'
        constraints=[hbox(lmin,plotmin,lmax,plotmax)]        
        padding=0
        Label: lmin:
            text='plot min'
        Field: plotmin:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmin=-1
                else:
                    waveform.plotmin=float(text)
                waveform.updateFigure()
        Label: lmax:
            text='plot max'
        Field: plotmax:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmax=-1
                else:
                    waveform.plotmax=float(text)
                waveform.updateFigure()
    
    Container: details:
        constraints=[vbox(hbox(nameField,timeControls,channelControls),transitions)]
        hug_height='strong'
        hug_width='strong'

        Field: nameField:
            constraints = [width == 150, height == 20]
            text:=waveform.name

        GroupBox: timeControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l0,spin0,addButton0,removeButton0)]
            Label: l0:
                text='times'
            SpinBox: spin0:
                minimum=0
                maximum<<len(waveform.transitions.array)
            PushButton: addButton0:
                text='+'
                clicked::
                    waveform.addTransition(spin0.value)
            PushButton: removeButton0:
                text='-'
                clicked::
                    waveform.removeTransition(spin0.value)

        GroupBox: channelControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l1,spin1,addButton1,removeButton1)]
            Label: l1:
                text='channels'
            SpinBox: spin1:
                minimum=0
                maximum<<len(waveform.channelList)
            PushButton: addButton1:
                text='+'
                clicked::
                    waveform.addChannel(spin1.value)
            PushButton: removeButton1:
                text='-'
                clicked::
                    waveform.removeChannel(spin1.value)
        GroupBox: transitions:
            hug_height='strong'
            hug_width='strong'
            title='waveform transition and sequence (valid states: blank(continue), 0(off), 1(on))'
            constraints<<[grid(*[statesDyno.objects[i:(i+len(waveform.transitions.array)+1)] for i in range(0, len(statesDyno.objects), len(waveform.transitions.array)+1)])] if len(statesDyno.objects)>0 else []
            Include: statesDyno:
                objects<<[DescriptionLabel()]+[TransitionDescription(transition=t) for t in waveform.transitions.array]+[TimeLabel()]+[TransitionTime(transition=t,experiment=waveform.experiment,waveform=waveform) for t in waveform.transitions.array]+(list(itertools.chain(*map(list,zip(*([[ChannelCombo(wfm=waveform,channels=waveform.digitalout.channels,channelList=waveform.channelList,position=i) for i in xrange(len(waveform.channelList))]]+[[NumpyState(state=s,experiment=waveform.experiment,waveform=waveform) for s in waveform.sequence.array.flat][i:i+len(waveform.channelList)] for i in range(0,waveform.sequence.array.size,len(waveform.channelList))]))))) if (len(waveform.channelList)>0) else [])

def get_load_waveform_callback(HSDIO):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                HSDIO.import_waveform(dlg.path)
            except PauseError:
                pass
    return load_file_callback

enamldef Waveforms(Container):
    attr HSDIO

    Container:
        hug_height='strong'
        hug_width='strong'
        constraints=[vbox(buttons,c1),align('left',buttons,c1)]
        Container: buttons:
            constraints=[hbox(combo,importWaveform,addWaveform,removeWaveform,copyWaveform)]
            hug_height='strong'
            hug_width='strong'
            ComboBox: combo:
                constraints=[(width==500)|'strong']
                items << list(HSDIO.waveforms.names)
                index = (0 if (HSDIO.waveforms.length>0) else -1) # pick first profile on load
            PushButton: importWaveform:
                enabled = False
                #add a waveform from a file
                text='import'
                clicked::
                    dlg = FileDialog(
                        parent=importWaveform,
                        title='Choose file to load waveform from',
                        mode='open_file',
                        path=HSDIO.import_path,
                        callback=get_load_waveform_callback(HSDIO),
                        ).open()
                    combo.index=len(HSDIO.waveforms)-1
            PushButton: addWaveform:
                constraints=[(width==50)|'strong']
                text = 'add'
                clicked::
                    HSDIO.waveforms.add()
                    combo.index=len(HSDIO.waveforms)-1
            PushButton: removeWaveform:
                constraints=[(width==50)|'strong']
                text = 'remove'
                clicked::
                    i=combo.index
                    if i>=0:
                        if i>1:
                            combo.index=i-1
                        else:
                            combo.index=0
                        HSDIO.waveforms.pop(i)
            PushButton: copyWaveform:
                constraints=[(width==50)|'strong']
                text = 'copy'
                clicked::
                    HSDIO.waveforms.copy(combo.index)
                    combo.index=len(HSDIO.waveforms)-1
        Container: c1:
            padding=0
            Conditional:
                condition << ((HSDIO.waveforms.length>0) and (combo.index >= 0))
                Container:
                    padding=0
                    constraints=[vbox(canvas,stack),align('left',canvas,stack)]
                    MPLCanvas: canvas:
                        constraints=[(height==500)|'strong',(width==1500)|'strong']
                        figure << HSDIO.waveforms.listProperty[combo.index].figure
                    Container: stack:
                        padding=0
                        # There were too many problems with getting a stack to update properly, so we are using the slower to switch but
                        # quicker to instantiate single element
                        NumpyWaveform:
                            waveform << HSDIO.waveforms.listProperty[combo.index]
#        Stack: stack:
#            index<<combo.index
#            RefreshableLooper:
#                iterable<<HSDIO.waveforms
#                StackItem:
#                    NumpyWaveform:
#                        waveform<<loop_item


enamldef HSDIO_DigitalOutPage(Page):
    attr HSDIO
    title = 'HSDIO Pulses'

    Container:
        Container:
                constraints=[hbox(vbox(p1,p9,p2,p4,p5,p6,p7,p8),p3),align('left',p1,p9,p2,p4,p5,p6,p7),align('top',p1,p3)]
                hug_height='strong'
                hug_width='strong'
                EvalProp: p1:
                    prop<<HSDIO.enable
                StartTrigger: p9:
                    trigger<<HSDIO.startTrigger
                IndexedStack: p2:
                    title='Script Triggers'
                    iterable<<HSDIO.triggers
                    viewType=HSDIOScriptTrigger
                MultilineProp: p3:
                    prop<<HSDIO.script
                EvalProp: p4:
                    prop<<HSDIO.resourceName
                EvalProp: p5:
                    prop<<HSDIO.clockRate
                EvalProp: p6:
                    prop<<HSDIO.units
                EvalProp: p7:
                    prop<<HSDIO.hardwareAlignmentQuantum
                NumpyDOchannels: p8:
                    channels<<HSDIO.channels

enamldef DAQmxDigitalOutPage(Page):
    title = 'DAQmx DO'    
    attr DAQmx
    
    Container:
        Container:
                constraints=[vbox(canvas,p6,hbox(vbox(p0,p1,p2,p3,p4),p5)),align('top',p0,p5)]
                hug_height='strong'
                hug_width='strong'
                EvalProp: p0:
                    prop<<DAQmx.enable
                EvalProp: p1:
                    prop<<DAQmx.resourceName
                EvalProp: p2:
                    prop<<DAQmx.clockRate
                EvalProp: p3:
                    prop<<DAQmx.units
                StartTrigger: p4:
                    trigger<<DAQmx.startTrigger
                NumpyDOchannels: p5:
                    channels<<DAQmx.channels
                NumpyWaveform: p6:
                    waveform<<DAQmx.waveform
                MPLCanvas: canvas:
                    constraints=[(height==500)|'strong',(width==1500)|'strong']
                    figure << DAQmx.waveform.figure

enamldef DDS_profile(Container):
    attr profile
    
    hug_height='strong'
    hug_width='strong'
    padding=0

    Container:
        padding=0
        hug_height='strong'
        hug_width='strong'
        constraints=[vbox(description,hbox(container1,container2))]
        Form: description:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=profile.description
        Container: container1:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.frequency
            EvalProp:
                prop<<profile.amplitude
            EvalProp:
                prop<<profile.phase
            EvalProp:
                prop<<profile.RAMMode
            EvalProp:
                prop<<profile.ZeroCrossing
            EvalProp:
                prop<<profile.NoDwellHigh
            EvalProp:
                prop<<profile.FunctionOrStatic
        Container: container2:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.RAMFunction
            EvalProp:
                prop<<profile.RAMInitialValue
            EvalProp:
                prop<<profile.RAMStepValue
            EvalProp:
                prop<<profile.RAMTimeStep
            EvalProp:
                prop<<profile.RAMNumSteps
            IndexedStack:
                title='RAMStaticArray'
                iterable<<profile.RAMStaticArray
                viewType=ItemProp

enamldef ItemProp(StackItem):
    attr item
    
    Container:
        padding=0
        EvalProp:
            prop<<item

enamldef DDS_channel(GroupBox):
    attr channel
    attr index
    
    title='channel '+str(index)
    constraints=[hbox(vbox(parameters,RAM),profiles)]

    GroupBox: parameters:
        title='channel parameters'
        flat=True
        constraints=[vbox(description,power,refClockRate,fullScaleOutputPower)]
        Form: description:
            Label:
                text='description'
            Field:
                text:=channel.description
        EvalProp: power:
            prop<<channel.power
        EvalProp: refClockRate:
            prop<<channel.refClockRate
        EvalProp: fullScaleOutputPower:
            prop<<channel.fullScaleOutputPower
    
    GroupBox: RAM:
        title='RAM defaults'
        flat=True
        EvalProp:
            prop<<channel.RAMenable
        EvalProp:
            prop<<channel.RAMDestType
        EvalProp:
            prop<<channel.RAMDefaultFrequency
        EvalProp:
            prop<<channel.RAMDefaultAmplitude
        EvalProp:
            prop<<channel.RAMDefaultPhase

    GroupBox: profiles:
        title='profiles'
        hug_height='strong'
        hug_width='strong'
        ComboBox: combo:
            items << list(channel.profileDescriptionList)
            index = (0 if (channel.profiles.length>0) else -1) # pick first profile on load
#        Stack: p1:
#            index<<combo.index
#            RefreshableLooper:
#                iterable<<channel.profiles
#                StackItem:
#                    DDS_profile:
#                        profile<<loop_item
        Conditional:
            condition << ((channel.profiles.length>0) and (combo.index >= 0))
            DDS_profile:
                profile << channel.profiles.listProperty[combo.index]

enamldef DDS_box(Form):
    attr box

    Label:
        text='enable'
    CheckBox:
        checked:=box.enable

    Label:
        text='Description'
    Field:
        text:=box.description

    PushButton:
        text='select USB device reference'
        clicked::
            box.deviceReference=combo.selected_item.strip()
    ComboBox: combo:
        items<<list(box.DDS.deviceList)

    Label:
        text='NI USB-8451 device reference'
    Field:
        pass
        text:=box.deviceReference

    Label:
        text='DIO port'
    IntField:
        #maximum = sys.maxint  # this crashes on Windows, but not on OS X
        maximum = 999999
        minimum = 0
        value:=box.DIOport
    Label:
        text='serialClockRate'
    IntField:
        value := box.serialClockRate

    GroupBox:
        hug_height='strong'
        hug_width='strong'
        title='channels'
        RefreshableLooper:
            iterable<<box.channels
            DDS_channel:
                index<<loop_index
                channel<<loop_item

enamldef DDS_Page(Container): page:
    attr DDS

    Container:
        hug_width='strong'
        hug_height='strong'
        constraints=[vbox(hbox(enable,isInit,getDevicesButton,initButton,loadButton),stackGroup),align('v_center',getDevicesButton,initButton,loadButton,enable,isInit),enable.width==500,getDevicesButton.width==200,initButton.width==200,loadButton.width==200]
        EvalProp: enable:
                    prop<<DDS.enable
        PushButton: getDevicesButton:
            text='Get DDS Device List'
            clicked::DDS.getDDSDeviceListThread()
        PushButton: initButton:
            text='Initialize and Load'
            clicked::DDS.initializeDDSThread()
        PushButton: loadButton:
            text='Load'
            clicked::DDS.loadDDSThread()

        #LabelBox: enable:
        #    text='enable'
        #    checked:=DDS.enable.value

        LabelBox: isInit:
            text='initialized?'
            checked<<DDS.isInitialized
            enabled=False #keep it greyed out.

        GroupBox: stackGroup:
            pass
            title='DDS boxes'
            constraints=[vbox(hbox(combo,addButton,removeButton),stack),stack.width==contents_width]
            ComboBox: combo:
                items<<list(DDS.boxDescriptionList)
                index = (0 if (DDS.boxes.length>0) else -1) # pick first profile on load
            PushButton: addButton:
                text='+'
                constraints=[width==50,height==20]
                clicked::
                    DDS.boxes.add()
                    DDS.updateBoxDescriptionList()
                    combo.index=len(DDS.boxes)-2 #point to new box
            PushButton: removeButton:
                text='-'
                constraints=[width==50,height==20]
                clicked::
                    i=combo.index
                    if i>=0:
                        DDS.boxes.pop(i)
                        DDS.updateBoxDescriptionList()
                        combo.index=i-1
#            Stack: stack:
#                index<<combo.index
#                RefreshableLooper:
#                    iterable<<DDS.boxes
#                    StackItem:
#                        DDS_box:
#                            box<<loop_item
            Container: stack:
                padding = 0
                Conditional:
                    condition << ((DDS.boxes.length>0) and (combo.index >= 0))
                    DDS_box:
                        box<<DDS.boxes.listProperty[combo.index]

enamldef RF_gen(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            Label:
                text='description'
            Field:
                text:=item.description
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power

enamldef HP83623A(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            
            Label:
                text='description'
            Field:
                text:=item.description
            
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power
        EvalProp:
            prop<<item.RFoutput
        EvalProp:
            prop<<item.externalTrigger

enamldef RFGenPage(Page):
    attr LabView
    title = 'RF Generators'
    Container:
        EvalProp:
            prop<<LabView.RF_generators.enable
        IndexedStack: i1:
            title='HP83623A'
            iterable=LabView.RF_generators.HP83623A_list
            viewType=HP83623A
        IndexedStack: i2:
            title='HP8662A'
            iterable=LabView.RF_generators.HP8662A_list
            viewType=RF_gen
        IndexedStack: i3:
            title='HP83712B'
            iterable=LabView.RF_generators.HP83712B_list
            viewType=RF_gen

enamldef CameraPage(Page):
    attr camera
    title = 'Camera'
    Container:
        Container:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<camera.enable
            EvalProp:
                prop<<camera.saveAsPNG
            EvalProp:
                prop<<camera.saveAsASCII
            EvalProp:
                prop<<camera.forceImagesToU16
            EvalProp:
                prop<<camera.EMGain
            EvalProp:
                prop<<camera.analogGain
            EvalProp:
                prop<<camera.exposureTime
            EvalProp:
                prop<<camera.scanSpeed
            EvalProp:
                prop<<camera.lowLightSensitivity
            EvalProp:
                prop<<camera.externalTriggerMode
            EvalProp:
                prop<<camera.triggerPolarity
            EvalProp:
                prop<<camera.externalTriggerSource
            EvalProp:
                prop<<camera.cooling
            EvalProp:
                prop<<camera.fan
            EvalProp:
                prop<<camera.scanMode
            EvalProp:
                prop<<camera.photoelectronScaling
            EvalProp:
                prop<<camera.subArrayLeft
            EvalProp:
                prop<<camera.subArrayTop
            EvalProp:
                prop<<camera.subArrayWidth
            EvalProp:
                prop<<camera.subArrayHeight
            EvalProp:
                prop<<camera.superPixelBinning
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionLeft
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionTop
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionRight
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionBottom
            EvalProp:
                prop<<camera.numImageBuffers
            EvalProp:
                prop<<camera.shotsPerMeasurement

enamldef CounterPage(Page):
    title = 'Counter'

enamldef FiltersPage(Page):
    title = 'Filters'

enamldef AOequation(StackItem):
    attr item
    Container:
        hug_height='strong'
        hug_width='strong'
        GroupBox:
            flat=True
            title='description'
            Field:
                constraints=[width==500]
                text:=item.description
                placeholder='description'
        GroupBox:
            flat=True
            title='function'
            Field:
                constraints=[width==500]
                text:=item.function
                placeholder='function that evaluates to a 1D array, where t will be replaced with AO.timesteps'

enamldef AnalogOutputPage(Page):
    attr AO
    title = 'Analog output'
    Container:
        hug_height='strong'
        #hug_width='strong'
        constraints=[vbox(e1,canvas,equations,c1),align('left',e1,canvas,equations,c1)]
        #constraints=[vbox(e1,equations,c1),align('left',e1,equations,c1)]
        LabelBox: e1:
            text='enable'
            checked:=AO.enable
        #the following 4 lines are for chaco plotting
        #EnableCanvas: canvas:
        #    #TODO: make this expand and shrink nicely while filling the width
        #    constraints=[height==500,width==1500]
        #    component<<AO.plot
        #the following lines are for MPL plotting
        MPLCanvas: canvas:
            constraints=[(height==500)|'strong']
            hug_width='ignore'
            figure << AO.figure
        IndexedStack: equations:
            title='equations'
            iterable<<AO.equations
            viewType=AOequation
        Container: c1:
            hug_height='strong'
            hug_width='strong'
            constraints=[grid([e2,e3,e4],[e5,e6,e7],[e8,e9,e10],[e11,e12])]
            EvalProp: e2:
                prop<<AO.physicalChannels
            EvalProp: e3:
                prop<<AO.minimum
            EvalProp: e4:
                prop<<AO.maximum
            EvalProp: e5:
                prop<<AO.clockRate
            EvalProp: e6:
                prop<<AO.units
            EvalProp: e7:
                prop<<AO.totalAOTime
            EvalProp: e8:
                prop<<AO.waitForStartTrigger
            EvalProp: e9:
                prop<<AO.triggerSource
            EvalProp: e10:
                prop<<AO.triggerEdge
            EvalProp: e11:
                prop<<AO.exportStartTrigger
            EvalProp: e12:
                prop<<AO.exportStartTriggerDestination

enamldef PiezoChannel(Container):
    attr channel
    
    hug_height = 'strong'
    hug_width = 'strong'
    constraints=[hbox(description, setServo,setPosition,label)]
    Field: description:
        placeholder='description'
        text:=channel.description
    EvalProp: setServo:
        prop<<channel.setServo
    EvalProp: setPosition:
        prop<<channel.setPosition
    GroupBox: label:
        flat=True
        title='read from piezo'
        Label:
            text<<'axis:{}\tservo:{}\tposition:'.format(channel.readAxis,channel.readServo,channel.readPosition)

enamldef PiezoController(StackItem):
    attr item
    
    Container:
        hug_height = 'strong'
        hug_width = 'strong'
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
            Label:
                text='enable'
            CheckBox:
                checked::item.enable
            Label:
                text='serial number set:'
            Field:
                placeholder='serial number'
                text:=item.serialNumber
            Label:
                text='id:'
            Label:
                text:=item.identificationRead
            Label:
                text='serial number read:'
            Label:
                text:=item.serialNumberRead
        RefreshableLooper:
            iterable<<item.channels
            PiezoChannel:
                channel<<loop_item

enamldef PI_PiezoPage(Page):
    attr piezo
    title = 'PI Piezo'
    Container:
        LabelBox:
            text='enable'
            checked:=piezo.enable
        IndexedStack:
            title='Piezo Controllers'
            iterable<<piezo.controllers
            viewType=PiezoController

enamldef PicomotorPage(Page):
    title = 'Picomotor'

enamldef AnalysisImage(Container):
    attr analysis
    
    padding=0
    constraints=[(height==550)|'strong',(width==550)|'strong']
    MPLCanvas:
        constraints=[(height==550)|'strong',(width==550)|'strong']
        figure<<analysis.figure


enamldef MultiImagePage(Page): page:
    title='Images'
    attr experiment
    attr analysis0
    attr analysis1
    attr analysis2
    attr analysis3

    Container:
        constraints=[vbox(l0,hbox(a0,a1,a2)),align('top',a0,a1,a2)]
        
        Label: l0:
            text<<analysis3.text

        Container: a0:
            hug_height = 'strong'
            hug_width = 'strong'
            AnalysisImage:
                analysis<<analysis0
            Form:
                Label:
                    text = 'Show ROIs?'
                CheckBox:
                    checked := analysis0.showROIs
                Label:
                    text = 'shot'
                SpinBox:
                    minimum=0
                    value := analysis0.shot

        Container: a1:
            hug_height='strong'
            hug_width='strong'
            AnalysisImage:
                analysis<<analysis1
            Form:
                Label:
                   text='Show ROIs?'
                CheckBox:
                    checked:=analysis1.showROIs
            GroupBox:
                hug_height='strong'
                hug_width='strong'
                Looper:
                    iterable << analysis1.ivarNames
                    Form:
                        Label:
                            text<<loop_item
                        ComboBox:
                            items<<[str(i) for i in analysis1.ivarValueLists[loop_index]]
                            index::
                                analysis1.setIteration(loop_index, index) #send which ivar (loop_index) to update to index
                Form:
                    Label:
                        text='Measurement'
                    SpinBox:
                        minimum=0
                        maximum=9999999 #a big number
                        value:=analysis1.measurement
                Form:
                    Label:
                        text='Shot'
                    SpinBox:
                        minimum=0
                        maximum=9999999 #a big number
                        value:=analysis1.shot
        Container: a2:
            hug_height = 'strong'
            hug_width = 'strong'
            AnalysisImage:
                analysis<<analysis2
            Form:
                Label:
                   text='Show ROIs?'
                CheckBox:
                    checked:=analysis2.showROIs
                Label:
                    text = 'shot'
                SpinBox:
                    minimum=0
                    value := analysis2.shot


enamldef SquareROI(Container):
    attr item
    attr num
    hug_height='strong'
    hug_width='strong'
    constraints=[hbox(l0,f0,f1,f2,f3,f4)]
    Label: l0:
        text=str(num)
    MyIntField: f0:
        placeholder='left'
        value:=item[0]
    MyIntField: f1:
        placeholder='top'
        value:=item[1]
    MyIntField: f2:
        placeholder='right'
        value:=item[2]
    MyIntField: f3:
        placeholder='bottom'
        value:=item[3]
    MyFloatField: f4:
        placeholder='threshold'
        value:=item[4]

enamldef ROIPage(Page):
    attr experiment
    attr analysis
    
    title='ROI'
    
    Container:
        hug_height='ignore'
        hug_width='ignore'
        constraints=[hbox(dynoCont,canvas),align('top',dynoCont,canvas)]
        Container: dynoCont:
            Include: dyno:
                objects<<[SquareROI(item=x,num=i) for i,x in enumerate(analysis.ROIs)]
        MPLCanvas: canvas:
            constraints=[(height==1000)|'strong',(width==1000)|'strong']
            hug_width='ignore'
            figure<<analysis.figure

enamldef HistogramPage(Page):
    attr experiment
    attr analysis

    title = 'Histogram'
    Container:
        hug_height='ignore'
        hug_width='ignore'
        Form:
            Label:
                text = 'shot'
            SpinBox:
                value := analysis.shot
                minimum = 0
                maximum << experiment.LabView.camera.shotsPerMeasurement.value
            Label:
                text = 'roi'
            SpinBox:
                value := analysis.roi
                minimum = 0
                maximum << len(experiment.squareROIAnalysis.ROIs)
        MPLCanvas:
            constraints=[(height==900)|'strong',(width==1700)|'strong']
            #hug_width='ignore'
            figure<<analysis.figure

enamldef MeasurementsGraphPage(Page):
    attr experiment
    attr analysis
    title = 'Measurements Graph'

    Container:
        hug_height='ignore'
        hug_width='ignore'
        Form:
            Label:
                text = 'shot'
            SpinBox:
                value := analysis.shot
                minimum = 0
                maximum << experiment.LabView.camera.shotsPerMeasurement.value
            Label:
                text = 'roi'
            SpinBox:
                value := analysis.roi
                minimum = 0
                maximum << len(experiment.squareROIAnalysis.ROIs)
        PushButton:
            text = 'clear'
            clicked::analysis.clear()
        MPLCanvas:
            constraints=[(height==900)|'strong',(width==1700)|'strong']
            figure<<analysis.figure

enamldef IterationsGraphPage(Page):
    attr experiment
    attr analysis
    title = 'Iterations Graph'

    Container:
        hug_height='ignore'
        hug_width='ignore'
        Form:
            Label:
                text = 'shot'
            SpinBox:
                value := analysis.shot
                minimum = 0
                maximum << experiment.LabView.camera.shotsPerMeasurement.value
            Label:
                text = 'roi'
            SpinBox:
                value := analysis.roi
                minimum = 0
                maximum << len(experiment.squareROIAnalysis.ROIs)
        MPLCanvas:
            constraints=[(height==900)|'strong',(width==1700)|'strong']
            figure<<analysis.figure

enamldef TTL_filters(Form):
    attr instrument
    attr filters

    Label:
        text = 'enable'
    CheckBox:
        checked := instrument.enable

    Label:
        text = 'lines'
    Field:
        text := instrument.lines

    Label:
        text = 'filter level'
    ComboBox:
        items = ['None: increment measurement total',
                 'soft: continue with other analyses, but do not increment measurement total',
                 'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                 'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
        index := filters.filter_level

    Label:
        text = 'Status'
    Label:
        text := filters.text

enamldef Optimizer(Form):
    attr experiment
    attr analysis

    Label:
        text='cost function'
    MultilineField:
        constraints=[height==600]
        text:=experiment.optimizer.costfunction

    Label:
        text='update method'
    ComboBox:
        items=['Nelder-Mead','genetic','gradient descent']

    MPLCanvas: canvas:
        constraints=[(height==1000)|'strong',(width==1000)|'strong']
        hug_width='ignore'
        figure<<analysis.figure

enamldef Main(MainWindow): main:
    attr experiment
    
    title='Saffmanlab experiment controller'
    initial_position=(0,0)
    initial_size=(1500,1100)
    #icon_source='icon://myicons/atom_loading'
    
    CsMenuBar:
        experiment=main.experiment
        mainWindow=main
    StatusBar:
        StatusItem:
            Label:
                text << 'Status: {}, Iteration: {}, Measurement: {}, Good Measurements: {}, Progress: {}%'.format(experiment.statusStr,experiment.iterationStr,experiment.measurementStr,experiment.goodMeasurementsStr,experiment.progressGUI)
        StatusItem:
            ProgressBar: progress:
                #constraints=[width==1200]
                minimum=0
                maximum=100
                value<<int(experiment.progressGUI)
    Container:
        padding = 0
        ScrollArea:
            Container:
                hug_height='strong'
                hug_width='strong'
                Notebook: notebook:
                    tabs_closable=False
                    tabs_movable=False
                    tab_style = 'preferences'
                    ExperimentPage:
                        experiment=main.experiment
                    VariablesPage:
                        experiment=main.experiment
                    LabViewPage:
                        LabView=main.experiment.LabView
                    HSDIO_DigitalOutPage:
                        HSDIO=main.experiment.LabView.HSDIO
                    #HSDIO_DigitalOutPage:
                    #    HSDIO=main.experiment.LabView.HSDIO2
                    Page:
                        title='Waveforms'
                        Waveforms:
                            HSDIO=main.experiment.LabView.HSDIO
                    DAQmxDigitalOutPage:
                        DAQmx=main.experiment.LabView.DAQmxDO
                    Page:
                        title = 'DDS'
                        DDS_Page:
                            DDS=main.experiment.LabView.DDS
                    RFGenPage:
                        LabView=main.experiment.LabView
                    CameraPage:
                        camera=main.experiment.LabView.camera
                    #CounterPage:
                    #    pass
                    AnalogOutputPage:
                        AO=main.experiment.LabView.AnalogOutput
                    PI_PiezoPage:
                        piezo=main.experiment.LabView.piezo
                    MultiImagePage:
                        experiment=main.experiment
                        analysis0=main.experiment.recent_shot_analysis
                        analysis1=main.experiment.shotBrowserAnalysis
                        analysis2=main.experiment.imageSumAnalysis
                        analysis3=main.experiment.text_analysis
                    ROIPage:
                        experiment=main.experiment
                        analysis=main.experiment.squareROIAnalysis
                    HistogramPage:
                        experiment=main.experiment
                        analysis=main.experiment.histogramAnalysis
                    MeasurementsGraphPage:
                       experiment=main.experiment
                       analysis=main.experiment.measurements_graph
                    IterationsGraphPage:
                       experiment=main.experiment
                       analysis=main.experiment.iterations_graph
                    Page:
                        title='TTL filter'
                        TTL_filters:
                            instrument = main.experiment.LabView.TTL
                            filters = main.experiment.TTL_filters
                    Page:
                        title='Optimization'
                        Optimizer:
                            experiment=main.experiment
                            analysis=main.experiment.optimizer
