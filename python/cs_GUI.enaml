"""
author = 'Martin Lichtman'
created = 2013-04-02
modified >= 2014-04-21

cs_GUI.enaml

A GUI for the Cs experiment controller, written using the enaml toolkit for python.
"""

from __future__ import division
__author__ = 'Martin Lichtman'
import logging
logger = logging.getLogger(__name__)

from cs_errors import PauseError

from enaml.layout.api import vbox, hbox, align, horizontal, vertical, spacer, grid
from enaml.widgets.api import (MainWindow, MenuBar, Menu, Action,
                                Notebook, Page, Container, GroupBox, 
                                Form, Label, CheckBox, SpinBox, PushButton, MPLCanvas,
                                MultilineField, ProgressBar, ScrollArea, Separator,
                                FileDialog,Window, StatusBar, StatusItem,
                                Stack, StackItem, ComboBox, HGroup, VGroup
)
from enaml.icon import Icon, IconImage
from enaml.image import Image
from enaml.core.declarative import d_
from enaml.core.include import Include
from enaml.stdlib.fields import FloatField, IntField
from enaml.core.api import Looper, Conditional
from enaml.styling import StyleSheet, Style, Setter
from enaml.validator import Validator
from atom.api import Member, Bool, Typed, observe, Callable
import threading, datetime, time, os, itertools
import numpy, itertools

from experiments import IndependentVariable
from instrument_property import ListProp

# redefine Field so that all Fields will have status_tips
from enaml.widgets.api import Field as OldField
enamldef Field(OldField):
    status_tip << text

enamldef MyStyleSheet(StyleSheet):
    Style:
        style_class = 'invalid'
        Setter:
            field = 'background-color'
            value = 'pink'
        Setter:
            field = 'border-color'
            value = 'red'
        Setter:
            field = 'border-style'
            value = 'solid'
        Setter:
            field = 'border-width'
            value = '2'
    Style:
        style_class = 'valid'

enamldef RefreshableLooper(Looper): self:
    """A Looper that sends a reference of itself to the backend controller, so it can be forcibly updated using the
    refresh_items() method."""
    initialized::
        iterable.gui = self

class MyBoolValidator(Validator):
    experiment=Member()

    def __init__(self,experiment):
        super(MyBoolValidator,self).__init__()
        self.experiment=experiment

    def validate(self,text):
        try:
            value = self.experiment.eval_bool(text)
        except:
            return False
        return True


class MyEnumValidator(Validator):
    experiment=Member()
    allowedValues=Member()

    def __init__(self,experiment,allowedValues):
        super(MyEnumValidator,self).__init__()
        self.experiment=experiment
        self.allowedValues=allowedValues

    def validate(self,text):
        try:
            value = self.experiment.eval_general(text)
        #check for parsing errors
        except:
            return False
        #check if the value is one of the ones allowed by this particular Enum
        if value not in self.allowedValues:
            return False
        #if we've gotten this far, all tests have passed
        return True

#TODO: make these Fields have validation and able to process statements
enamldef MyIntField(Field):
    """This class exists to make an IntField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = int(text)

enamldef MyFloatField(Field):
    """This class exists to make a FloatField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = float(text)

enamldef MyBoolField(Field):
    """This class exists to make a BoolField (which isn't something that is available anyway),
     that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = bool(text)

enamldef IndexedStack(GroupBox): indexedStack:
    attr iterable=Typed(ListProp)
    attr viewType #=Class(StackItem)  #do we really have to declare what type? I suppose this was so that we would be okay with creating an instance
    hug_height = 'strong'
    hug_width = 'strong'

    Container: controls:
        constraints=[hbox(addButton,removeButton,combo)]
        PushButton: addButton:
            text='+'
            constraints=[width==50,height==20]
            clicked::
                iterable.add()
                combo.maximum=len(iterable)-1
                combo.value=combo.maximum
        PushButton: removeButton:
            text='-'
            constraints=[width==50,height==20]
            clicked::
                i=combo.value
                if i>=0:
                    iterable.pop(i)
                    combo.maximum=len(iterable)-1
                    if i>1:
                        combo.value=i-1
                    else:
                        combo.value=0
        # RefreshableComboBox: combo:
            # items<<[str(i)+' '+n.description for i,n in enumerate(iterable)]
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum<<len(iterable)-1
            minimum=0
    Stack: stack:
        index<<combo.value
        RefreshableLooper:
            iterable<<indexedStack.iterable
            Include:
                objects=[viewType(item=loop_item)]

enamldef IndexedContainer(GroupBox):
    # This is like an IndexedStack, but instead of using a stack, we just have only one object to display and we
    # change what that one object is using an Include
    # The attribute 'iterable' must be a ListProp.  This container then provides controls to add and remove elements.
    # The GUI element viewType must define 'item' which is the element of the ListProp that will be passed to it
    # The attribute static disables the buttons to dynamically add or remove list items

    attr iterable = Typed(ListProp)
    # Below is commented out because we don't actually have to declare the type.
    # This was so that we would be okay with creating an instance, but it's not necessary
    attr viewType  # = Class(StackItem)
    # The attribute static disables the buttons to dynamically add or remove list items
    attr dynamic = True

    hug_height = 'strong'
    hug_width = 'strong'

    HGroup:
        #constraints=[hbox(addButton,removeButton,combo)]
        Conditional:
            condition = dynamic
            PushButton: addButton:
                text='+'
                constraints=[width==50,height==20]
                clicked::
                    iterable.add()
                    combo.maximum=len(iterable)-1
                    combo.value=combo.maximum
            PushButton: removeButton:
                text='-'
                constraints=[width==50,height==20]
                clicked::
                    i=combo.value
                    if i>=0:
                        iterable.pop(i)
                        combo.maximum=len(iterable)-1
                        if i>1:
                            combo.value=i-1
                        else:
                            combo.value=0
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum<<len(iterable)-1
            minimum=0
    # the actual thing to display
    Conditional:
        condition << ((iterable.length>0) and (combo.value >=0))
        Include:
           objects << [viewType(item=iterable[combo.value])]

def get_load_file_callback(experiment):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.load(dlg.path)
            except PauseError:
                pass
    return load_file_callback

def get_save_file_callback(experiment):
    def save_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.save(dlg.path)
            except PauseError:
                pass
    return save_file_callback

enamldef CsMenuBar(MenuBar): menuBar:
    attr experiment
    attr mainWindow
    
    Menu:
        title = '&File'
        Action:
            text = 'Load\tCtrl+L'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Choose file to load',
                    mode='open_file',
                    path=experiment.settings_path,
                    callback=get_load_file_callback(experiment),
                    ).open()
        Action:
            text = 'Save\tCtrl+S'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Save As?',
                    mode='save_file',
                    path=os.path.join(experiment.settings_path,'settings-{}.hdf5'.format(datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S'))),
                    callback=get_save_file_callback(experiment),
                    ).open()
        Action:
            text = 'Quit\tCtrl+Q'
            triggered::
                mainWindow.close()
    Menu:
        title = '&Experiment'
        Action:
            text = 'Reset and Run\tCtrl+R'
            triggered::experiment.resetAndGoThread()
        Action:
            text = 'Reset'
            triggered::experiment.resetThread()
        Action:
            text = 'Run'
            triggered::experiment.goThread()
        Menu:
            title = 'Pause...'
            Action:
                checkable = True
                text = 'After Measurement'
                checked := experiment.pauseAfterMeasurement
            Action:
                checkable = True
                text = 'After Iteration'
                checked := experiment.pauseAfterIteration
            Action:
                checkable = True
                text = 'After Error'
                checked := experiment.pauseAfterError
        Action:
            text = 'Continue\tCtrl+G'
            triggered::experiment.goThread()
        Action:
            text = 'End and Upload'
            triggered::experiment.endThread()
        Action:
            text = 'Halt\tCtrl+H'
            triggered::experiment.halt()

enamldef EvalProp(GroupBox):
    attr prop
    padding = 0
    flat = True
    title << prop.name
    constraints = [desc.width==func.width, func.width==val.width, hbox(desc,func,val), align('v_center',desc,func,val)]

    # can be made to show an error status by setting valid to false
    attr valid = True

    Field: desc:
        text := prop.description
        placeholder = 'description'

    Field: func:
        text := prop.function
        placeholder = prop.placeholder
        style_class << 'valid' if prop.valid else 'invalid'

    Label: val:
        text << prop.valueStr

enamldef MultilineProp(GroupBox):        
    attr prop
    flat=True
    title:=prop.name
    constraints=[vbox(desc,hbox(func,val)),align('top',func,val)]
    Field: desc:
        text:=prop.description
        placeholder='description'
    MultilineField: func:
        text:=prop.function
    Label: val:
        text << prop.valueStr

enamldef LabelBox(HGroup):
    alias checked: box.checked
    alias text: label.text
    
    padding=0
    hug_height='strong'
    hug_width='strong'
    align_widths = False

    Label: label:
        pass
    CheckBox: box:
        pass

enamldef CheckField(HGroup):
    alias checked: box.checked
    alias text: field.text
    alias placeholder: field.placeholder

    padding = 0
    hug_height='strong'
    hug_width='strong'
    align_widths = False

    CheckBox: box:
        pass
    Field: field:
        pass

enamldef LabelField(VGroup):
    alias label: l1.text
    alias text: f1.text
    alias placeholder: f1.placeholder

    padding = 0
    hug_height='strong'
    hug_width='strong'

    Label: l1:
        pass
    Field: f1:
        pass

#class RefreshableComboBox(ComboBox):
#    refresh = EnamlEvent

enamldef ExperimentPage(Container):
    attr experiment

    Form: form:
        constraints = [(midline==left)|'strong',(width==parent.contents_width)|'strong']
        Label:
            text="Status:"
        Label:
            text<<experiment.statusStr

        Label:
            text='Pause after iteration'
        CheckBox:
            checked:=experiment.pauseAfterIteration

        Label:
            text='Pause after measurement'
        CheckBox:
            checked:=experiment.pauseAfterMeasurement

        Label:
            text='Pause after error'
        CheckBox:
            checked:=experiment.pauseAfterError

        Label:
            text = 'enable sounds'
        CheckBox:
            checked := experiment.enable_sounds

        Label:
            text = 'start each instrument in a separate thread'
        CheckBox:
            checked := experiment.enable_instrument_threads

        Label: text='Save Data?'
        CheckField:
            checked:=experiment.saveData
            text:=experiment.localDataPath
            placeholder='local data path'

        Label: text='Save Settings?'
        CheckBox:
            checked:=experiment.saveSettings

        Label: text='Save 2013 style files?'
        CheckBox:
            checked:=experiment.save2013styleFiles

        Label: text='Copy Data to Network?'
        CheckField:
            checked:=experiment.copyDataToNetwork
            text:=experiment.networkDataPath
            placeholder='network data path'

        Label: text='Experiment description suffix for filename'
        Field: text:=experiment.experimentDescriptionFilenameSuffix

        Label: text='Measurement Timeout [s]'
        FloatField: value:=experiment.measurementTimeout

        Label: text='Measurements per Iteration'
        IntField: value:=experiment.measurementsPerIteration

        Label: text='E-mail on error/completion?'
        CheckField:
            checked:=experiment.willSendEmail
            text:=experiment.emailAddresses

        Label: text='Progress'
        Label: text<<'{}%'.format(experiment.progressGUI)

        Label: text='Iteration'
        Label: text<<experiment.iterationStr

        Label: text='Measurement'
        Label: text<<experiment.measurementStr

        Label: text='Good Measurements'
        Label: text<<experiment.goodMeasurementsStr

        Label: text='Time started'
        Label: text<<experiment.timeStartedStr

        Label: text='Time after last measurement'
        Label: text<<experiment.currentTimeStr

        Label: text='Time elapsed'
        Label: text<<experiment.timeElapsedStr

        Label: text='Estimated total time'
        Label: text<<experiment.totalTimeStr

        Label: text='Estimated time remaining'
        Label: text<<experiment.timeRemainingStr

        Label: text='Estimated completion time'
        Label: text<<experiment.completionTimeStr

        Label: text='Notes'
        MultilineField:
            text:=experiment.notes

enamldef VariableEntry(GroupBox):
    attr indepVar

    hug_height = 'strong'
    hug_width = 'strong'
    constraints = [vbox(variable,optimizer,values,status), align('left',variable,optimizer,values,status)]  # currentValueLabel.right==funcCont.right

    HGroup: variable:
        align_widths = False
        constraints = [nameCont.width==0.5*descCont.width, descCont.width==funcCont.width]
        Field: nameCont:
            text := indepVar.name
            placeholder = 'name'
        Field: descCont:
            text := indepVar.description
            placeholder = 'description'
        Field: funcCont:
            text := indepVar.function
            placeholder = 'function'
    HGroup: optimizer:
        padding = 0
        align_widths = False
        hug_width = 'strong'
        hug_height = 'strong'
        Form:
            Label:
                text = 'optimize?'
            CheckBox:
                checked := indepVar.optimize
        Form:
            Label:
                text = 'initial step'
            FloatField:
                value := indepVar.optimizer_initial_step
        Form:
            Label:
                text = 'min'
            FloatField:
                value := indepVar.optimizer_min
        Form:
            Label:
                text = 'max'
            FloatField:
                value := indepVar.optimizer_max
    HGroup: values:
        Label:
            text << 'values: '+indepVar.valueListStr
    HGroup: status:
        hug_width = 'strong'
        hug_height = 'strong'
        # constraints = [align('v_center',stepsLabel,currentValueLabel)]
        Label: stepsLabel:
            text << 'step: '+str(indepVar.index)+' of '+str(indepVar.steps)
        Label: currentValueLabel:
            text << 'current value: '+indepVar.currentValueStr

enamldef IndependentVariablesGroupBox(GroupBox):
    attr independentVariables
    title='Independent Variables (2)'

    hug_height='strong'
    hug_width='strong'

    GroupBox:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton0,removeButton0)]
        SpinBox: spin0:
            minimum=0
            maximum << independentVariables.length
        PushButton: addButton0:
            text='+'
            clicked::
                independentVariables.add_at(spin0.value)
        PushButton: removeButton0:
            text='-'
            clicked::
                independentVariables.pop(spin0.value)

    RefreshableLooper:
        iterable<<independentVariables
        VariableEntry:
            indepVar << loop_item

enamldef Variables(Container): page:
    attr experiment

    PushButton: updateButton:
        text='Update variables throughout experiment'
        clicked::
            experiment.evaluateAll()
    GroupBox: variablesNotToSave:
        hug_height='strong'
        title='Variables Not To Save to HDF5 (comma separated)'
        Field:
            text:=experiment.variablesNotToSave
            placeholder='scipy,numpy,x'

    Container:
        padding = 0
        hug_height = 'ignore'
        constraints = [hbox(constants, independents, dependents), align('top', constants, independents, dependents), constants.width==dependents.width]

        GroupBox: constants:
            title='Constants (1)'

            Label:
                text='Define constants using python code below.'
            MultilineField:
                constraints = [bottom==page.contents_bottom]
                text:=experiment.constantsStr

        IndependentVariablesGroupBox: independents:
            independentVariables<<experiment.independentVariables

        GroupBox: dependents:
            title='Dependent Variables (3)'

            Label:
                text='Define dependent variables using python code below.'
            MultilineField:
                constraints = [bottom==page.contents_bottom]
                text:=experiment.dependentVariablesStr

enamldef Reports(Container):
    attr experiment
    HGroup:
        GroupBox:
            title = 'Constant Report'
            hug_height = 'strong'
            hug_width = 'strong'
            constraints = [hbox(f1,lb1),align('top',f1,lb1)]
            MultilineField: f1:
                constraints = [height==950, width==600]
                text := experiment.constantReport.function
                style_class << 'valid' if experiment.constantReport.valid else 'invalid'
            Label: lb1:
                text << experiment.constantReport.valueStr
        GroupBox:
            title = 'Variable Report'
            hug_height = 'strong'
            hug_width = 'strong'
            constraints = [hbox(f2,lb2),align('top',f2,lb2)]
            MultilineField: f2:
                constraints = [height==950, width==600]
                text := experiment.variableReport.function
                style_class << 'valid' if experiment.variableReport.valid else 'invalid'
            Label: lb2:
                text << experiment.variableReport.valueStr

enamldef LabViewPage(Container):
    attr LabView

    hug_height='strong'
    Container:
        constraints=[hbox(b1,b3,b4),b1.width==100,b3.width==100,b4.width==100]
        PushButton: b1:
            text='open connection'
            clicked::
                LabView.openThread()
        PushButton: b3:
            text='update settings'
            clicked::
                LabView.update()
        PushButton: b4:
            text='close connection'
            clicked::
                LabView.close()

    Form:
        Label:
            text='enable communication with LabView system?'
        CheckBox:
            checked:=LabView.enable
        Label:
            text='IP address of LabView system'
        Field:
            text:=LabView.IP
        Label:
            text='communications port'
        IntField:
            value:=LabView.port
        Label:
            text='cycle experiment continuously even when not taking data?'
        CheckBox:
            checked:=LabView.cycleContinuously
    EvalProp:
        prop<<LabView.timeout
    Form:
        Label:
            text='connected'
        CheckBox:
            checked:=LabView.connected
            enabled=False
        Label: text='LabView error'
        Label: text<<str(LabView.error)

    GroupBox:
        title='TCP output message'
        constraints = [vbox(scroller1),(height==500)|'strong']
        hug_width='ignore'
        ScrollArea:scroller1:
            Container:
                hug_height='ignore'
                hug_width='ignore'
                Label:
                    hug_height='ignore'
                    hug_width='ignore'
                    text<<LabView.msg

    GroupBox:
        title='LabView log'
        constraints = [vbox(scroller2),(height==500)|'strong']
        hug_width='ignore'
        ScrollArea: scroller2:
            Container:
                hug_height='ignore'
                hug_width='ignore'
                Label:
                    hug_height='ignore'
                    hug_width='ignore'
                    text<<LabView.log

enamldef DOchannel(Container):
    attr channel
    attr index
    hug_height='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel.description
        placeholder='description'
    Field: activeF:
        text:=channel.active.function
        placeholder='active?'
    Label: activeL:
        text<<str(channel.active.value)

enamldef HSDIOScriptTrigger(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
        EvalProp:
            prop<<item.id
        EvalProp:
            prop<<item.source
        EvalProp:
            prop<<item.type
        EvalProp:
            prop<<item.edge
        EvalProp:
            prop<<item.level

enamldef StartTrigger(GroupBox):
    attr trigger
    title='Start Trigger'
    
    EvalProp:
        prop<<trigger.waitForStartTrigger
    EvalProp:
        prop<<trigger.source
    EvalProp:
        prop<<trigger.edge

class RefreshableMPLCanvas(MPLCanvas):
    """ An MPLCanvas that can be refreshed on command by toggling refresh.
    Requires adding a function to MPLCanvas in
    C:\Users\Saffmanlab\AppData\Local\Enthought\Canopy\User\Lib\site-packages\enaml\qt\qt_mpl_canvas.py:
        def on_action_set_refresh(self, content):
            self.refresh_mpl_widget()
    """
    
    #: Toggle this to refresh the canvas
    refresh = d_(Bool())

class RemoveEventContainer(Container):
    remove=d_(Bool())

enamldef NumpyDOchannel(Container):
    attr channel
    attr index
    attr digitalout #the DAQmxDO or HSDIO
    attr experiment

    hug_height='strong'
    hug_width='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel['description']
        placeholder='description'
    Field: activeF:
        text:=channel['function']
        placeholder='active?'
        validator<<MyBoolValidator(experiment)
        text::
            channel['value']=experiment.eval_bool(text)
            activeL.text=str(channel['value']) #must be updated manually because the channel['value'] identity does not change
            digitalout.evaluate()
    Label: activeL:
        text<<str(channel['value'])

enamldef NumpyDOchannels(GroupBox):
    attr channels
    title='channels (#, description, active?)'
    hug_height='strong'
    hug_width='strong'
    #constraints=[controls.left==dynoCont.left]
    Container: controls:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton,removeButton)]
        SpinBox: spin0:
            minimum=0
            maximum<<len(channels.array)
        PushButton: addButton:
            text='+'
            clicked::
                channels.add(spin0.value)
        PushButton: removeButton:
            text='-'
            clicked::
                channels.remove(spin0.value)
    Container: dynoCont:
        Include: dyno:
            objects<<[NumpyDOchannel(channel=x,index=i,digitalout=channels.digitalout,experiment=channels.experiment) for i,x in enumerate(channels.array)]

enamldef NumpyState(Form):
    attr state
    attr experiment
    attr waveform
    attr value_str
    attr valid

    padding=0

    Field:
        constraints = [width == 100,height==20]
        style_class << 'valid' if valid else 'invalid'
        text:=state['function']
        text::
            value, parent.valid = experiment.eval_general(text)
            if value is None:
                state['value'] = 5
                parent.value_str = ''
            elif (value == 0) or (value ==1):
                state['value'] = value
                parent.value_str = str(state['value']) #must be updated manually because state['value'] identity does not change
            else:
                logger.warning('Invalid state in waveform {}.  States must evaluate to None, 0 or 1.\n{} = {}'.format(waveform.name,text,value))
                state['value'] = 5
                parent.value_str = ''
                parent.valid = False
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width==50, height==20]
        text << value_str

enamldef ChannelCombo(ComboBox):
    attr wfm
    attr channels
    attr channelList
    attr position
    
    items<<[str(i)+' '+x for i,x in enumerate(channels.array['description'])]
    index<<int(channelList[position])
    index::
        channelList[position]=numpy.uint8(index)
        wfm.updateFigure()

enamldef TransitionsLabel(Container):
    padding=0
    Label:
        constraints = [height == 20]
        text='description'
    Label:
        constraints = [height == 20]
        text='time'

enamldef DescriptionLabel(Label):
    constraints = [height == 20]
    text='description'
    
enamldef TimeLabel(Label):
    constraints = [height == 20]
    text='time'

enamldef TransitionDescription(Field):
    attr transition
    constraints = [height==20]
    placeholder = 'description'
    text:=transition['description']

enamldef TransitionTime(Form):
    attr experiment
    attr waveform
    attr transition
    attr value_str
    attr valid
    
    padding=0
    
    Field:
        constraints = [width == 100, height==20]
        placeholder = 'time'
        text := transition['function']
        style_class << 'valid' if valid else 'invalid'
        text::
            transition['value'], parent.valid = experiment.eval_float(text)
            value_str = '{:.6f}'.format(transition['value']) #must be updated manually because transition['value'] identity does not change
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width==50, height==20]
        text << value_str

enamldef NumpyWaveform(Container):
    attr waveform
    
    hug_height='strong'
    hug_width='ignore'
    constraints=[vbox(plotcontrols,details),align('left',plotcontrols,details)]
    
    Container: plotcontrols:
        hug_width='strong'
        hug_height='strong'
        constraints=[hbox(lmin,plotmin,lmax,plotmax)]
        padding=0
        Label: lmin:
            text='plot min'
        Field: plotmin:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmin=-1
                else:
                    waveform.plotmin=float(text)
                waveform.updateFigure()
        Label: lmax:
            text='plot max'
        Field: plotmax:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmax=-1
                else:
                    waveform.plotmax=float(text)
                waveform.updateFigure()
    
    Container: details:
        constraints=[vbox(hbox(nameField,timeControls,channelControls),transitions)]
        hug_height='strong'
        hug_width='strong'

        Field: nameField:
            constraints = [width == 150, height == 20]
            text:=waveform.name

        GroupBox: timeControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l0,spin0,addButton0,removeButton0)]
            Label: l0:
                text='times'
            SpinBox: spin0:
                minimum=0
                maximum<<len(waveform.transitions.array)
            PushButton: addButton0:
                text='+'
                clicked::
                    waveform.addTransition(spin0.value)
            PushButton: removeButton0:
                text='-'
                clicked::
                    waveform.removeTransition(spin0.value)

        GroupBox: channelControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l1,spin1,addButton1,removeButton1)]
            Label: l1:
                text='channels'
            SpinBox: spin1:
                minimum=0
                maximum<<len(waveform.channelList)
            PushButton: addButton1:
                text='+'
                clicked::
                    waveform.addChannel(spin1.value)
            PushButton: removeButton1:
                text='-'
                clicked::
                    waveform.removeChannel(spin1.value)
        GroupBox: transitions:
            hug_height='strong'
            hug_width='strong'
            title='waveform transition and sequence (valid states: blank(continue), 0(off), 1(on))'
            constraints<<[grid(*[statesDyno.objects[i:(i+len(waveform.transitions.array)+1)] for i in range(0, len(statesDyno.objects), len(waveform.transitions.array)+1)])] if len(statesDyno.objects)>0 else []
            Include: statesDyno:
                objects << ([DescriptionLabel()]
                    +[TransitionDescription(transition=t) for t in waveform.transitions.array]
                    +[TimeLabel()]
                    +[TransitionTime(transition=t,experiment=waveform.experiment,waveform=waveform,value_str=value_str,valid=valid) for t,value_str,valid in zip(waveform.transitions.array,waveform.transitions.value_str,waveform.transitions.valid)]
                    +(list(itertools.chain(*map(list,zip(*([[ChannelCombo(wfm=waveform,channels=waveform.digitalout.channels,channelList=waveform.channelList,position=i) for i in xrange(len(waveform.channelList))]]
                    +[[NumpyState(state=s,experiment=waveform.experiment,waveform=waveform,value_str=value_str,valid=valid) for s,value_str,valid in zip(waveform.sequence.array.flat,waveform.sequence.value_str.flat,waveform.sequence.valid.flat)][i:i+len(waveform.channelList)] for i in range(0,waveform.sequence.array.size,len(waveform.channelList))]))))) if (len(waveform.channelList)>0) else [])
                    )

def get_load_waveform_callback(HSDIO):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                HSDIO.import_waveform(dlg.path)
            except PauseError:
                pass
    return load_file_callback

enamldef Waveforms(Container):
    attr HSDIO

    Container:
        hug_height='strong'
        hug_width='strong'
        constraints=[vbox(buttons,c1),align('left',buttons,c1)]
        Container: buttons:
            constraints=[hbox(combo,importWaveform,addWaveform,removeWaveform,copyWaveform)]
            hug_height='strong'
            hug_width='strong'
            ComboBox: combo:
                constraints=[(width==500)|'strong']
                items << list(HSDIO.waveforms.names)
                index = (0 if (HSDIO.waveforms.length>0) else -1) # pick first profile on load
            PushButton: importWaveform:
                enabled = False
                #add a waveform from a file
                text='import'
                clicked::
                    dlg = FileDialog(
                        parent=importWaveform,
                        title='Choose file to load waveform from',
                        mode='open_file',
                        path=HSDIO.import_path,
                        callback=get_load_waveform_callback(HSDIO),
                        ).open()
                    combo.index=len(HSDIO.waveforms)-1
            PushButton: addWaveform:
                constraints=[(width==50)|'strong']
                text = 'add'
                clicked::
                    HSDIO.waveforms.add()
                    combo.index=len(HSDIO.waveforms)-1
            PushButton: removeWaveform:
                constraints=[(width==50)|'strong']
                text = 'remove'
                clicked::
                    i=combo.index
                    if i>=0:
                        if i>1:
                            combo.index=i-1
                        else:
                            combo.index=0
                        HSDIO.waveforms.pop(i)
            PushButton: copyWaveform:
                constraints=[(width==50)|'strong']
                text = 'copy'
                clicked::
                    HSDIO.waveforms.copy(combo.index)
                    combo.index=len(HSDIO.waveforms)-1
        Container: c1:
            padding=0
            Conditional:
                condition << ((HSDIO.waveforms.length>0) and (combo.index >= 0))
                Container:
                    padding=0
                    constraints=[vbox(canvas,stack),align('left',canvas,stack)]
                    MPLCanvas: canvas:
                        constraints=[(height==1000)|'strong',(width==1500)|'strong']
                        figure << HSDIO.waveforms.listProperty[combo.index].figure
                    Container: stack:
                        padding=0
                        # There were too many problems with getting a stack to update properly, so we are using the slower to switch but
                        # quicker to instantiate single element
                        NumpyWaveform:
                            waveform << HSDIO.waveforms.listProperty[combo.index]

enamldef HSDIO_DigitalOutPage(Container):
    attr HSDIO

    constraints=[hbox(vbox(p1,p9,p2,p4,p5,p6,p7,p8),p3),align('left',p1,p9,p2,p4,p5,p6,p7),align('top',p1,p3)]
    hug_height='strong'
    hug_width='strong'
    Form: p1:
        Label:
            text = 'enable'
        CheckBox:
            checked := HSDIO.enable
    StartTrigger: p9:
        trigger<<HSDIO.startTrigger
    IndexedStack: p2:
        title='Script Triggers'
        iterable<<HSDIO.triggers
        viewType=HSDIOScriptTrigger
    MultilineProp: p3:
        prop<<HSDIO.script
    EvalProp: p4:
        prop<<HSDIO.resourceName
    EvalProp: p5:
        prop<<HSDIO.clockRate
    EvalProp: p6:
        prop<<HSDIO.units
    EvalProp: p7:
        prop<<HSDIO.hardwareAlignmentQuantum
    NumpyDOchannels: p8:
        channels<<HSDIO.channels

enamldef DAQmxDigitalOutPage(Container):
    attr DAQmx
    
    constraints=[vbox(canvas,p6,hbox(vbox(p0,p1,p2,p3,p4),p5)),align('top',p0,p5)]
    hug_height='strong'
    hug_width='strong'
    Form: p0:
        Label:
            text = 'enable'
        CheckBox:
            checked := DAQmx.enable
    EvalProp: p1:
        prop<<DAQmx.resourceName
    EvalProp: p2:
        prop<<DAQmx.clockRate
    EvalProp: p3:
        prop<<DAQmx.units
    StartTrigger: p4:
        trigger<<DAQmx.startTrigger
    NumpyDOchannels: p5:
        channels<<DAQmx.channels
    NumpyWaveform: p6:
        waveform<<DAQmx.waveform
    MPLCanvas: canvas:
        constraints=[(height==500)|'strong',(width==1500)|'strong']
        figure << DAQmx.waveform.figure

enamldef DDS_profile(Container):
    attr profile
    
    hug_height='strong'
    hug_width='strong'
    padding=0

    Container:
        padding=0
        hug_height='strong'
        hug_width='strong'
        constraints=[vbox(description,hbox(container1,container2))]
        Form: description:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=profile.description
        Container: container1:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.frequency
            EvalProp:
                prop<<profile.amplitude
            EvalProp:
                prop<<profile.phase
            EvalProp:
                prop<<profile.RAMMode
            EvalProp:
                prop<<profile.ZeroCrossing
            EvalProp:
                prop<<profile.NoDwellHigh
            EvalProp:
                prop<<profile.FunctionOrStatic
        Container: container2:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.RAMFunction
            EvalProp:
                prop<<profile.RAMInitialValue
            EvalProp:
                prop<<profile.RAMStepValue
            EvalProp:
                prop<<profile.RAMTimeStep
            EvalProp:
                prop<<profile.RAMNumSteps
            IndexedStack:
                title='RAMStaticArray'
                iterable<<profile.RAMStaticArray
                viewType=ItemProp

enamldef ItemProp(StackItem):
    attr item
    
    Container:
        padding=0
        EvalProp:
            prop<<item

enamldef DDS_channel(GroupBox):
    attr channel
    attr index
    
    title='channel '+str(index)
    constraints=[hbox(vbox(parameters,RAM),profiles)]

    GroupBox: parameters:
        title='channel parameters'
        flat=True
        constraints=[vbox(description,power,refClockRate,fullScaleOutputPower)]
        Form: description:
            Label:
                text='description'
            Field:
                text:=channel.description
        EvalProp: power:
            prop<<channel.power
        EvalProp: refClockRate:
            prop<<channel.refClockRate
        EvalProp: fullScaleOutputPower:
            prop<<channel.fullScaleOutputPower
    
    GroupBox: RAM:
        title='RAM defaults'
        flat=True
        EvalProp:
            prop<<channel.RAMenable
        EvalProp:
            prop<<channel.RAMDestType
        EvalProp:
            prop<<channel.RAMDefaultFrequency
        EvalProp:
            prop<<channel.RAMDefaultAmplitude
        EvalProp:
            prop<<channel.RAMDefaultPhase

    GroupBox: profiles:
        title='profiles'
        hug_height='strong'
        hug_width='strong'
        ComboBox: combo:
            items << list(channel.profileDescriptionList)
            index = (0 if (channel.profiles.length>0) else -1) # pick first profile on load
#        Stack: p1:
#            index<<combo.index
#            RefreshableLooper:
#                iterable<<channel.profiles
#                StackItem:
#                    DDS_profile:
#                        profile<<loop_item
        Conditional:
            condition << ((channel.profiles.length>0) and (combo.index >= 0))
            DDS_profile:
                profile << channel.profiles.listProperty[combo.index]

enamldef DDS_box(Form):
    attr box

    Label:
        text='enable'
    CheckBox:
        checked:=box.enable

    Label:
        text='Description'
    Field:
        text:=box.description

    PushButton:
        text='select USB device reference'
        clicked::
            box.deviceReference=combo.selected_item.strip()
    ComboBox: combo:
        items<<list(box.DDS.deviceList)

    Label:
        text='NI USB-8451 device reference'
    Field:
        pass
        text:=box.deviceReference

    Label:
        text='DIO port'
    IntField:
        #maximum = sys.maxint  # this crashes on Windows, but not on OS X
        maximum = 999999
        minimum = 0
        value:=box.DIOport
    Label:
        text='serialClockRate'
    IntField:
        value := box.serialClockRate

    GroupBox:
        hug_height='strong'
        hug_width='strong'
        title='channels'
        RefreshableLooper:
            iterable<<box.channels
            DDS_channel:
                index<<loop_index
                channel<<loop_item

enamldef DDS_Page(Container): page:
    attr DDS

    Container:
        hug_width='strong'
        hug_height='strong'
        constraints=[vbox(hbox(enable,isInit,getDevicesButton,initButton,loadButton),stackGroup),align('v_center',getDevicesButton,initButton,loadButton,enable,isInit),enable.width==500,getDevicesButton.width==200,initButton.width==200,loadButton.width==200]
        Form:
            Label:
                text = 'enable'
            CheckBox: enable:
                checked := DDS.enable
        PushButton: getDevicesButton:
            text='Get DDS Device List'
            clicked::DDS.getDDSDeviceListThread()
        PushButton: initButton:
            text='Initialize and Load'
            clicked::DDS.initializeDDSThread()
        PushButton: loadButton:
            text='Load'
            clicked::DDS.loadDDSThread()

        #LabelBox: enable:
        #    text='enable'
        #    checked:=DDS.enable.value

        LabelBox: isInit:
            text='initialized?'
            checked<<DDS.isInitialized
            enabled=False #keep it greyed out.

        GroupBox: stackGroup:
            pass
            title='DDS boxes'
            constraints=[vbox(hbox(combo,addButton,removeButton),stack),stack.width==contents_width]
            ComboBox: combo:
                items<<list(DDS.boxDescriptionList)
                index = (0 if (DDS.boxes.length>0) else -1) # pick first profile on load
            PushButton: addButton:
                text='+'
                constraints=[width==50,height==20]
                clicked::
                    DDS.boxes.add()
                    DDS.updateBoxDescriptionList()
                    combo.index=len(DDS.boxes)-2 #point to new box
            PushButton: removeButton:
                text='-'
                constraints=[width==50,height==20]
                clicked::
                    i=combo.index
                    if i>=0:
                        DDS.boxes.pop(i)
                        DDS.updateBoxDescriptionList()
                        combo.index=i-1
#            Stack: stack:
#                index<<combo.index
#                RefreshableLooper:
#                    iterable<<DDS.boxes
#                    StackItem:
#                        DDS_box:
#                            box<<loop_item
            Container: stack:
                padding = 0
                Conditional:
                    condition << ((DDS.boxes.length>0) and (combo.index >= 0))
                    DDS_box:
                        box<<DDS.boxes.listProperty[combo.index]

enamldef RF_gen(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            Label:
                text='description'
            Field:
                text:=item.description
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power

enamldef HP83623A(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            
            Label:
                text='description'
            Field:
                text:=item.description
            
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power
        EvalProp:
            prop<<item.RFoutput
        EvalProp:
            prop<<item.externalTrigger

enamldef RFGenPage(Container):
    attr LabView

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked :=  LabView.RF_generators.enable
    IndexedStack: i1:
        title='HP83623A'
        iterable=LabView.RF_generators.HP83623A_list
        viewType=HP83623A
    IndexedStack: i2:
        title='HP8662A'
        iterable=LabView.RF_generators.HP8662A_list
        viewType=RF_gen
    IndexedStack: i3:
        title='HP83712B'
        iterable=LabView.RF_generators.HP83712B_list
        viewType=RF_gen

enamldef CameraPage(Container):
    attr camera

    hug_height='strong'
    hug_width='strong'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := camera.enable
    EvalProp:
        prop<<camera.saveAsPNG
    EvalProp:
        prop<<camera.saveAsASCII
    EvalProp:
        prop<<camera.forceImagesToU16
    EvalProp:
        prop<<camera.EMGain
    EvalProp:
        prop<<camera.analogGain
    EvalProp:
        prop<<camera.exposureTime
    EvalProp:
        prop<<camera.scanSpeed
    EvalProp:
        prop<<camera.lowLightSensitivity
    EvalProp:
        prop<<camera.externalTriggerMode
    EvalProp:
        prop<<camera.triggerPolarity
    EvalProp:
        prop<<camera.externalTriggerSource
    EvalProp:
        prop<<camera.cooling
    EvalProp:
        prop<<camera.fan
    EvalProp:
        prop<<camera.scanMode
    EvalProp:
        prop<<camera.photoelectronScaling
    EvalProp:
        prop<<camera.subArrayLeft
    EvalProp:
        prop<<camera.subArrayTop
    EvalProp:
        prop<<camera.subArrayWidth
    EvalProp:
        prop<<camera.subArrayHeight
    EvalProp:
        prop<<camera.superPixelBinning
    EvalProp:
        prop<<camera.frameGrabberAcquisitionRegionLeft
    EvalProp:
        prop<<camera.frameGrabberAcquisitionRegionTop
    EvalProp:
        prop<<camera.frameGrabberAcquisitionRegionRight
    EvalProp:
        prop<<camera.frameGrabberAcquisitionRegionBottom
    EvalProp:
        prop<<camera.numImageBuffers
    EvalProp:
        prop<<camera.shotsPerMeasurement

enamldef Andor(Container):
    attr camera
    attr analysis

    HGroup:
        Container:
            hug_height = 'strong'
            hug_width = 'strong'
            LabelBox:
                text = 'enable'
                checked := camera.enable
            HGroup:
                PushButton:
                    text = 'video mode'
                    clicked :: camera.setup_video(analysis)
                PushButton:
                    text = 'stop video'
                    clicked :: camera.stop_video()
            EvalProp:
                prop << camera.EMCCDGain
            EvalProp:
                prop << camera.preAmpGain
            EvalProp:
                prop << camera.exposureTime
            ComboBox:
                items = ['Edge', 'Level']
                index := camera.triggerMode
            EvalProp:
                prop<<camera.shotsPerMeasurement
        Container:
            MPLCanvas:
                figure << analysis.figure
            Form:
                Label:
                    text = 'shot'
                SpinBox: shot:
                    minimum=0
                    value := analysis.shot

enamldef FiltersPage(Page):
    title = 'Filters'

enamldef AOequation(StackItem):
    attr item
    Container:
        hug_height='strong'
        hug_width='strong'
        GroupBox:
            flat=True
            title='description'
            Field:
                constraints=[width==500]
                text:=item.description
                placeholder='description'
        GroupBox:
            flat=True
            title='function'
            Field:
                constraints=[width==500]
                text:=item.function
                placeholder='function that evaluates to a 1D array, where t will be replaced with AO.timesteps'

enamldef AnalogOutput(Container):
    attr AO

    hug_height='strong'
    #hug_width='strong'
    constraints=[vbox(e1,canvas,equations,c1),align('left',e1,canvas,equations,c1)]
    LabelBox: e1:
        text='enable'
        checked:=AO.enable
    MPLCanvas: canvas:
        constraints=[(height==500)|'strong']
        hug_width='ignore'
        figure << AO.figure
    IndexedStack: equations:
        title='equations'
        iterable<<AO.equations
        viewType=AOequation
    Container: c1:
        hug_height='strong'
        hug_width='strong'
        constraints=[grid([e2,e3,e4],[e5,e6,e7],[e8,e9,e10],[e11,e12])]
        EvalProp: e2:
            prop<<AO.physicalChannels
        EvalProp: e3:
            prop<<AO.minimum
        EvalProp: e4:
            prop<<AO.maximum
        EvalProp: e5:
            prop<<AO.clockRate
        EvalProp: e6:
            prop<<AO.units
        EvalProp: e7:
            prop<<AO.totalAOTime
        EvalProp: e8:
            prop<<AO.waitForStartTrigger
        EvalProp: e9:
            prop<<AO.triggerSource
        EvalProp: e10:
            prop<<AO.triggerEdge
        EvalProp: e11:
            prop<<AO.exportStartTrigger
        EvalProp: e12:
            prop<<AO.exportStartTriggerDestination

enamldef AnalogInput(Container):
    attr AI

    hug_height='strong'
    hug_width='strong'
    LabelBox:
        text='enable'
        checked := AI.enable
    EvalProp:
        prop << AI.sample_rate
    EvalProp:
        prop << AI.source
    EvalProp:
        prop << AI.samples_per_measurement
    EvalProp:
        prop << AI.waitForStartTrigger
    EvalProp:
        prop << AI.triggerSource
    EvalProp:
        prop << AI.triggerEdge

enamldef DCNoiseEaterChannel(Container):
    attr item

    Form:
        Label:
            text = 'Set: Allow settings on computer overwrite those on noise eater'
        CheckBox:
            checked := item.update
        Label:
            text = 'Get: Allow settings on noise eater to overwrite those on computer'
        CheckBox:
            checked := item.allow_get

        # variables from DC noise eater
        # read/write variables
        Label:
            text = 'mode'
        ComboBox:
            items = ['off', 'run', 'idle-hi', 'idle-med', 'idle-lo', 'ramp']
            index := item.mode
        Label:
            text = 'trigger warning?'
        CheckBox:
            checked := item.warnSetting
        Label:
            text = 'limit range'
        IntField:
            value := item.limitRange
        Label:
            text = 'invert'
        CheckBox:
            checked := item.invert
        Label:
            text = 'integration time'
        IntField:
            value := item.integrationTime
        Label:
            text = 'trigger number'
        SpinBox:
            minimum = 0
            maximum = 3
            value := item.trigNum
        Label:
            text = 'measurements to average'
        IntField:
            value := item.measNum
        Label:
            text = 'Kp'
        EvalProp:
            prop << item.kp
        Label:
            text = 'Ki'
        EvalProp:
            prop << item.ki
        Label:
            text = 'setpoint'
        IntField:
            value := item.setpoint

        # read only
        Label:
            text = 'average'
        IntField:
            value << item.average
            enabled = False
        Label:
            text = 'error'
        IntField:
            value << item.error
            enabled = False
        Label:
            text = 'V in'
        IntField:
            value << item.vin
            enabled = False
        Label:
            text = 'V out'
        IntField:
            value << item.vout
            enabled = False
        Label:
            text = 'warning'
        CheckBox:
            checked << item.warning
            enabled = False

enamldef DCNoiseEater(Container):
    # represents an individual noise eater box
    attr item

    hug_height='strong'
    hug_width='strong'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := item.enable
        Label:
            text = 'COM port'
        Field:
            text := item.comport

    IndexedContainer:
        dynamic = False
        iterable << item.channels
        viewType = DCNoiseEaterChannel

enamldef DCNoiseEaters(Container):
    # creates an indexed display of the noise eater list
    attr DC_noise_eaters
    attr analysis
    attr filters

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        LabelBox:
            text = 'enable'
            checked := DC_noise_eaters.enable

        IndexedContainer:
            iterable << DC_noise_eaters.boxes
            viewType = DCNoiseEater

    # filter
    GroupBox:
        title = 'DC Noise Eater Filter'
        Form:
            Label:
                text = 'enable'
            CheckBox:
                checked := filters.enable

            Label:
                text = 'What to filter: a string representing a list of [(box,channel,variable,high,low), ...]'
            Field:
                text := filters.what_to_filter

            Label:
                text = 'filter level'
            ComboBox:
                items = ['None: increment measurement total',
                         'soft: continue with other analyses, but do not increment measurement total',
                         'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                         'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
                index := filters.filter_level

            Label:
                text = 'Status'
            Label:
                text := filters.text

    # cumulative plot of noise eater data
    GroupBox:
        title = 'DC Noise Eater plots'
        Form:
            Label:
                text = 'enable'
            CheckBox:
                checked := analysis.enable
            Label:
                text = 'specify box, channel and variable (see indices below) to graph with a list of tuples: [(box,channel,variable),(box,channel,variable)]\n 0:mode, 1:warnSetting, 2:limitRange, 3:invert, 4:integrationTime, 5:trigNum, 6:measNum, 7:kp, 8:ki, 9:setpoint, 10:average, 11:error, 12:vin, 13:vout, 14:warning'
            Field:
                text := analysis.list_of_what_to_plot
        PushButton:
            text = 'clear'
            clicked :: analysis.clear()
        MPLCanvas: canvas:
            constraints=[(height==500)|'strong']
            hug_width='ignore'
            figure << analysis.figure

enamldef Arroyo(Container):
    attr Arroyo

    hug_height = 'strong'
    hug_width = 'strong'

enamldef PiezoChannel(Container):
    attr channel
    
    hug_height = 'strong'
    hug_width = 'strong'
    constraints=[hbox(description, setServo,setPosition,label)]
    Field: description:
        placeholder='description'
        text:=channel.description
    EvalProp: setServo:
        prop<<channel.setServo
    EvalProp: setPosition:
        prop<<channel.setPosition
    GroupBox: label:
        flat=True
        title='read from piezo'
        Label:
            text<<'axis:{}\tservo:{}\tposition:'.format(channel.readAxis,channel.readServo,channel.readPosition)

enamldef PiezoController(StackItem):
    attr item
    
    Container:
        hug_height = 'strong'
        hug_width = 'strong'
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
            Label:
                text='enable'
            CheckBox:
                checked::item.enable
            Label:
                text='serial number set:'
            Field:
                placeholder='serial number'
                text:=item.serialNumber
            Label:
                text='id:'
            Label:
                text:=item.identificationRead
            Label:
                text='serial number read:'
            Label:
                text:=item.serialNumberRead
        RefreshableLooper:
            iterable<<item.channels
            PiezoChannel:
                channel<<loop_item

enamldef PI_Piezo(Container):
    attr piezo

    LabelBox:
        text='enable'
        checked:=piezo.enable
    IndexedStack:
        title='Piezo Controllers'
        iterable<<piezo.controllers
        viewType=PiezoController

enamldef AnalysisImage(Container):
    attr analysis
    
    padding=0
    constraints=[(height==550)|'strong',(width==550)|'strong']
    MPLCanvas:
        constraints=[(height==550)|'strong',(width==550)|'strong']
        figure<<analysis.figure

enamldef MultiImage(Container):
    attr experiment
    attr analysis0
    attr analysis1
    attr analysis2
    attr analysis3

    Label:
        text<<analysis3.text

    Container:
        padding = 0
        constraints = [hbox(a0,a1,a2), align('top',a0,a1,a2), a0.width==a1.width, a0.width==a2.width]

        Container: a0:
            #hug_height = 'strong'
            #hug_width = 'strong'
            MPLCanvas:
                #constraints=[(width==parent.width)|'strong',(height==width)|'strong']
                figure << analysis0.figure
            #AnalysisImage:
            #    analysis<<analysis0
            Form:
                Label:
                    text = 'Show ROIs?'
                CheckBox:
                    checked := analysis0.showROIs
                Label:
                    text = 'shot'
                SpinBox:
                    minimum=0
                    value := analysis0.shot

        Container: a1:
            #hug_height='strong'
            #hug_width='strong'
            MPLCanvas:
                #constraints=[(width==parent.width)|'strong',(height==width)|'strong']
                figure << analysis1.figure
            #AnalysisImage:
            #    analysis<<analysis1
            Form:
                Label:
                   text='Show ROIs?'
                CheckBox:
                    checked:=analysis1.showROIs
            GroupBox:
                hug_height='strong'
                hug_width='strong'
                Looper:
                    iterable << analysis1.ivarNames
                    Form:
                        Label:
                            text<<loop_item
                        ComboBox:
                            items<<[str(i) for i in analysis1.ivarValueLists[loop_index]]
                            index::
                                analysis1.setIteration(loop_index, index) #send which ivar (loop_index) to update to index
                Form:
                    Label:
                        text='Measurement'
                    SpinBox:
                        minimum=0
                        maximum=9999999 #a big number
                        value:=analysis1.measurement
                Form:
                    Label:
                        text='Shot'
                    SpinBox:
                        minimum=0
                        maximum=9999999 #a big number
                        value:=analysis1.shot
        Container: a2:
            #hug_height = 'strong'
            #hug_width = 'strong'
            #AnalysisImage:
            #    analysis<<analysis2
            MPLCanvas:
                #constraints=[(width==parent.width)|'strong',(height==width)|'strong']
                figure << analysis2.figure
            Form:
                Label:
                    text = 'enable'
                CheckBox:
                    checked := analysis2.enable
                Label:
                    text='Show ROIs?'
                CheckBox:
                    checked:=analysis2.showROIs
                Label:
                    text = 'shot'
                SpinBox:
                    minimum=0
                    value := analysis2.shot

enamldef SquareROI(Container):
    attr item
    attr num
    hug_height='strong'
    hug_width='strong'
    constraints=[hbox(l0,f0,f1,f2,f3,f4)]
    Label: l0:
        constraints = [(width==50)|'strong']
        text=str(num)
    MyIntField: f0:
        constraints = [(width==100)|'strong']
        placeholder='left'
        value:=item['left']
    MyIntField: f1:
        constraints = [(width==100)|'strong']
        placeholder='top'
        value:=item['top']
    MyIntField: f2:
        constraints = [(width==100)|'strong']
        placeholder='right'
        value:=item['right']
    MyIntField: f3:
        constraints = [(width==100)|'strong']
        placeholder='bottom'
        value:=item['bottom']
    MyFloatField: f4:
        constraints = [(width==100)|'strong']
        placeholder='threshold'
        value:=item['threshold']

enamldef SquareROIContainer(Container):
    attr experiment
    attr analysis
    
    hug_height='ignore'
    hug_width='ignore'
    constraints=[hbox(dynoCont,canvas),align('top',dynoCont,canvas)]
    Container: dynoCont:
        Container:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l0,l1,l2,l3,l4,l5)]
            Label: l0:
                constraints = [(width==50)|'strong']
                text = 'ROI#'
            Label: l1:
                constraints = [(width==100)|'strong']
                text = 'left'
            Label: l2:
                constraints = [(width==100)|'strong']
                text = 'top'
            Label: l3:
                constraints = [(width==100)|'strong']
                text = 'right'
            Label: l4:
                constraints = [(width==100)|'strong']
                text = 'bottom'
            Label: l5:
                constraints = [(width==100)|'strong']
                text = 'threshold'
        Include: dyno:
            objects<<[SquareROI(item=x,num=i) for i,x in enumerate(analysis.ROIs)]
    MPLCanvas: canvas:
        constraints=[(height==1000)|'strong',(width==1000)|'strong']
        hug_width='ignore'
        figure<<analysis.figure

enamldef GaussianROI(Container):
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    HGroup:
        Label:
            text = 'enable'
        CheckBox:
            checked := analysis.enable
        Label:
            text = 'shot'
        SpinBox:
            value := analysis.shot
        Label:
            text = 'clean up image with ICA?'
        CheckBox:
            checked := analysis.useICA
    HGroup:
        Label:
            text = 'initial guess'
        Label:
            text = 'top'
        FloatField:
            value := analysis.top
        Label:
            text = 'left'
        FloatField:
            value := analysis.left
        Label:
            text = 'bottom'
        FloatField:
            value := analysis.bottom
        Label:
            text = 'right'
        FloatField:
            value := analysis.right
    MPLCanvas:
        constraints=[(height==1000)|'strong',(width==1700)|'strong']
        figure<<analysis.figure

enamldef LoadingFilters(GroupBox):
    attr filters
    title = 'Region of Interest Sum (Loading) Filters'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := filters.enable

        Label:
            text = 'A boolean expression that evaluates the filter.\nUse t[shot,region] for the summation over any shot and region.\nFor example to require that sites 15 and 17 load: t[0,17]>20000 and t[0,15]>21000'
        Field:
            text := filters.filter_expression
            style_class << 'valid' if filters.valid else 'invalid'

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

        Label:
            text = 'Status'
        Label:
            text := filters.text

enamldef FirstMeasurementsFilter(GroupBox):
    attr filters
    title = 'Drop First N Measurements Filter'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := filters.enable

        Label:
            text = 'How many measurements should we drop at the beginning of each iteration?'
        SpinBox:
            minimum = 0
            value := filters.N

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

enamldef Histogram(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := analysis.enable
        Label:
            text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
        Field:
            text := analysis.list_of_what_to_plot
    MPLCanvas:
        constraints=[(height==900)|'strong',(width==1700)|'strong']
        #hug_width='ignore'
        figure<<analysis.figure

enamldef HistogramGrid(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := analysis.enable
        Label:
            text = 'shot'
        SpinBox:
            value := analysis.shot
    MPLCanvas:
        constraints=[(height==1700)|'strong',(width==1700)|'strong']
        figure<<analysis.figure

enamldef MeasurementsGraph(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := analysis.enable
        Label:
            text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
        Field:
            text := analysis.list_of_what_to_plot
    PushButton:
        text = 'clear'
        clicked :: analysis.clear()
    MPLCanvas:
        constraints = [(height==900)|'strong',(width==1700)|'strong']
        figure << analysis.figure

enamldef IterationsGraph(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
        Field:
            text := analysis.list_of_what_to_plot
    Container:
        constraints = [hbox(l5,cb5,l0,cb0,l1,cb1,l2,cb2,l3,f3,l4,f4)]
        Label: l5:
            text = 'enable'
        CheckBox: cb5:
            checked := analysis.enable
        Label: l0:
            text = 'draw connecting lines'
        CheckBox: cb0:
            checked := analysis.draw_connecting_lines
        Label: l1:
            text = 'draw error bars (1 sigma std dev of mean)'
        CheckBox: cb1:
            checked := analysis.draw_error_bars
        Label: l2:
            text = 'only add data that has passed loading filter'
        CheckBox: cb2:
            checked := analysis.add_only_filtered_data
        Label: l3:
            text = 'plot ymin'
        Field: f3:
            placeholder='blank for autolimit'
            text := analysis.ymin
        Label: l4:
            text = 'plot ymax'
        Field: f4:
            placeholder='blank for autolimit'
            text := analysis.ymax
    MPLCanvas:
        constraints=[(height==900)|'strong',(width==1700)|'strong']
        figure<<analysis.figure

enamldef RetentionGraph(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
        Field:
            text := analysis.list_of_what_to_plot
    Container:
        constraints = [hbox(l5,cb5,l0,cb0,l1,cb1,l2,cb2,l3,f3,l4,f4)]
        Label: l5:
            text = 'enable'
        CheckBox: cb5:
            checked := analysis.enable
        Label: l0:
            text = 'draw connecting lines'
        CheckBox: cb0:
            checked := analysis.draw_connecting_lines
        Label: l1:
            text = 'draw error bars (1 sigma binomial std dev of mean using normal approximation)'
        CheckBox: cb1:
            checked := analysis.draw_error_bars
        Label: l2:
            text = 'only add data that has passed loading filter'
        CheckBox: cb2:
            checked := analysis.add_only_filtered_data
        Label: l3:
            text = 'plot ymin'
        Field: f3:
            placeholder='blank for autolimit'
            text := analysis.ymin
        Label: l4:
            text = 'plot ymax'
        Field: f4:
            placeholder='blank for autolimit'
            text := analysis.ymax
    MPLCanvas:
        constraints=[(height==900)|'strong',(width==1700)|'strong']
        figure<<analysis.figure

enamldef TTL_filters(GroupBox):
    attr instrument
    attr filters
    title = 'TTL (Laser Lock Monitor) Filters'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := instrument.enable

        Label:
            text = 'lines'
        Field:
            text := instrument.lines

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

        Label:
            text = 'Status'
        Label:
            text := filters.text

enamldef Optimizer(Form):
    attr experiment
    attr analysis

    Label:
        text = 'enable'
    CheckBox:
        checked := analysis.enable
        enabled = False

    Label:
        text='update method'
    ComboBox:
        items = ['Nelder-Mead', 'genetic', 'gradient descent', 'weighted Nelder-Mead']
        index := analysis.optimization_method

    Label:
        text='End when step size is less than (fraction) on all axes'
    FloatField:
        value := analysis.end_condition_step_size

    Label:
        text='cost function'
    MultilineField:
        constraints=[height==300]
        text:=experiment.optimizer.cost_function

    MPLCanvas: canvas:
        constraints = [(height==3000)|'strong',(width==1000)|'strong']
        hug_width = 'ignore'
        figure << analysis.figure

enamldef Picomotor(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text = 'serial number'
        Field:
            text := item.serial_number
        Label:
            text = 'motor number'
        Field:
            text := item.motor_number
        Label:
            text = 'position'
        EvalProp:
            prop << item.desired_position

enamldef Picomotors(Container):
    attr picomotors

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Form:
            hug_width = 'strong'
            hug_height = 'strong'
            Label:
                text = 'enable'
            CheckBox:
                checked := picomotors.enable
            Label:
                text = 'IP Address'
            Field:
                text := picomotors.IP
            Label:
                text = 'port'
            IntField:
                value := picomotors.port

        IndexedContainer:
            iterable << picomotors.motors
            viewType = Picomotor

enamldef Filters(Container):
    attr experiment

    TTL_filters:
        instrument = experiment.LabView.TTL
        filters = experiment.TTL_filters
    LoadingFilters:
        filters = experiment.loading_filters
    FirstMeasurementsFilter:
        filters = experiment.first_measurements_filter

enamldef BoxTemperature(Container):
    attr box_temperature
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := box_temperature.enable
        Label:
            text = 'IP address'
        Field:
            text := box_temperature.IP
        Label:
            text = 'port'
        IntField:
            value := box_temperature.port
        Label:
            text = 'connected'
        CheckBox:
            checked << box_temperature.connected
            enabled = False

def loadIcon():
    #create icon
    with open(os.path.join('icons','2013_11_14_15_18_54_retention_PCA_filtered_image_rotated_smoothed.png'), 'rb') as f:
        data = f.read()
    image = Image(data=data)
    icon = Icon(images=[IconImage(image=image)])
    return icon

template ScrollPage(Title, Content):
    Page:
        alias content
        title = Title
        style_class << 'valid' if experiment.valid else 'invalid'
        Container:
            padding = 0
            style_class << 'valid' if experiment.valid else 'invalid'
            ScrollArea:
                style_class << 'valid' if experiment.valid else 'invalid'
                Content: content:
                    pass

enamldef Main(MainWindow): main:
    attr experiment
    
    title='Saffmanlab experiment controller'
    #initial_position=(0,0)
    #initial_size=(1500,1100)
    icon = loadIcon()

    MyStyleSheet:
        #just implement the style sheet defined separately
        pass
    CsMenuBar:
        experiment=main.experiment
        mainWindow=main
    StatusBar:
        StatusItem:
            Label:
                text << 'Status: {}, Iteration: {}, Measurement: {}, Good Measurements: {}, Progress: {}%'.format(experiment.statusStr,experiment.iterationStr,experiment.measurementStr,experiment.goodMeasurementsStr,experiment.progressGUI)
        StatusItem:
            ProgressBar: progress:
                #constraints=[width==1200]
                minimum=0
                maximum=100
                value<<int(experiment.progressGUI)
    Container:
        padding = 0
        Notebook: notebook:
            tabs_closable=False
            tabs_movable=False
            tab_style = 'preferences'
            size_hint_mode = 'current'

            ScrollPage('Experiment', ExperimentPage): p1:
                p1.content.experiment = main.experiment
            ScrollPage('Variables', Variables): p2:
                p2.content.experiment = main.experiment
            ScrollPage('Report', Reports): p3:
                p3.content.experiment = main.experiment
            ScrollPage('LabView', LabViewPage): p4:
                p4.content.LabView = main.experiment.LabView
            ScrollPage('HSDIO', HSDIO_DigitalOutPage): p5:
                p5.content.HSDIO = main.experiment.LabView.HSDIO
            ScrollPage('Waveforms', Waveforms): p6:
                p6.content.HSDIO = main.experiment.LabView.HSDIO
            ScrollPage('DAQmx', DAQmxDigitalOutPage): p7:
                p7.content.DAQmx = main.experiment.LabView.DAQmxDO
            ScrollPage('DDS', DDS_Page): p8:
                p8.content.DDS = main.experiment.LabView.DDS
            ScrollPage('RF Generators', RFGenPage): p9:
                p9.content.LabView = main.experiment.LabView
            ScrollPage('Hamamatsu', CameraPage): p10:
                p10.content.camera = main.experiment.LabView.camera
            ScrollPage('Andor', Andor): p11:
                p11.content.camera = main.experiment.Andor
                p11.content.analysis=main.experiment.andor_viewer
            ScrollPage('Analog Output', AnalogOutput): p12:
                p12.content.AO = main.experiment.LabView.AnalogOutput
            ScrollPage('Analog Input', AnalogInput): p13:
                p13.content.AI = main.experiment.LabView.AnalogInput
            #ScrollPage('Arroyo', Arroyo): p14:
            #    p14.content.arroyo = main.experiment.Arroyo
            ScrollPage('PI Piezo', PI_Piezo): p15:
                p15.content.piezo = main.experiment.LabView.piezo
            ScrollPage('Picomotors', Picomotors): p16:
                p16.content.picomotors = main.experiment.picomotors
            ScrollPage('Images', MultiImage): p17:
                p17.content.experiment = main.experiment
                p17.content.analysis0 = main.experiment.recent_shot_analysis
                p17.content.analysis1 = main.experiment.shotBrowserAnalysis
                p17.content.analysis2 = main.experiment.imageSumAnalysis
                p17.content.analysis3 = main.experiment.text_analysis
            ScrollPage('Square ROI',  SquareROIContainer): p18:
                p18.content.experiment = main.experiment
                p18.content.analysis = main.experiment.squareROIAnalysis
            ScrollPage('Gaussian ROI', GaussianROI): p19:
                p19.content.analysis = main.experiment.gaussian_roi
            ScrollPage('Histogram', Histogram): p20:
                p20.content.experiment = main.experiment
                p20.content.analysis = main.experiment.histogramAnalysis
            ScrollPage('Histogram Grid', HistogramGrid): p21:
                p21.content.experiment = main.experiment
                p21.content.analysis = main.experiment.histogram_grid
            ScrollPage('Measurements Graph', MeasurementsGraph): p22:
                p22.content.experiment = main.experiment
                p22.content.analysis = main.experiment.measurements_graph
            ScrollPage('Iterations Graph', IterationsGraph): p23:
                p23.content.experiment = main.experiment
                p23.content.analysis = main.experiment.iterations_graph
            ScrollPage('Retention Graph', RetentionGraph): p24:
                p24.content.experiment = main.experiment
                p24.content.analysis = main.experiment.retention_graph
            ScrollPage('Filters', Filters): p25:
                p25.content.experiment = main.experiment
            ScrollPage('Optimization', Optimizer): p26:
                p26.content.experiment = main.experiment
                p26.content.analysis = main.experiment.optimizer
            ScrollPage('DC Noise Eaters', DCNoiseEaters): p27:
                p27.content.DC_noise_eaters = main.experiment.DC_noise_eaters
                p27.content.analysis = main.experiment.DC_noise_eater_graph
                p27.content.filters = main.experiment.DC_noise_eater_filter
            ScrollPage('Box Temperature', BoxTemperature): p28:
                p28.content.box_temperature = main.experiment.box_temperature
