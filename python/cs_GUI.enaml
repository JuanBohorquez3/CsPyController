# Martin Lichtman
# created = 2013-04-02
# modified >= 2013-04-02

"""
Cs.enaml

A GUI for the Cs experiment controller, written using the enaml toolkit for python.
"""
from cs_errors import setupLog,PauseError
logger=setupLog(__name__)

from enaml.layout.api import vbox, hbox, align, horizontal, vertical, spacer, grid
from enaml.widgets.api import (MainWindow, MenuBar, Menu, Action,
                                Notebook, Page, Container, GroupBox, 
                                Form, Label, Field, CheckBox, SpinBox, PushButton, MPLCanvas,
                                MultilineField, ProgressBar, ScrollArea, Separator,
                                FileDialog,Window,
                                Stack, StackItem, ComboBox
)
from enaml.core.declarative import d_
from enaml.core.include import Include
from enaml.stdlib.fields import FloatField, IntField
from enaml.core.api import Looper, Conditional
from enaml.validator import Validator
from atom.api import Member
#from enaml.core.trait_types import EnamlEvent
#from enable_canvas import EnableCanvas
#from traitsui.api import View #requires "set ETS_TOOLKIT=qt4" on windows command line
from atom.api import Bool, Typed, observe, Callable
import os #for file dialogs
from sys import maxint
import threading, datetime, time
#from enthought.chaco.chaco_plot_editor import ChacoPlotItem
import numpy, itertools
from experiments import IndependentVariable
from instrument_property import ListProp

def get_load_file_callback(experiment):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.load(dlg.path)
            except PauseError:
                pass
    return load_file_callback

def get_save_file_callback(experiment):
    def save_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.save(dlg.path)
            except PauseError:
                pass
    return save_file_callback

class MyBoolValidator(Validator):
    experiment=Member()

    def __init__(self,experiment):
        super(MyBoolValidator,self).__init__()
        self.experiment=experiment

    def validate(self,text):
        try:
            value = self.experiment.eval_bool(text)
        except:
            return False
        return True

class MyFloatValidator(Validator):
    experiment=Member()

    def __init__(self,experiment):
        super(MyFloatValidator,self).__init__()
        self.experiment=experiment

    def validate(self,text):
        try:
            value = self.experiment.eval_float(text)
        except:
            return False
        return True

class MyEnumValidator(Validator):
    experiment=Member()
    allowedValues=Member()

    def __init__(self,experiment,allowedValues):
        super(MyEnumValidator,self).__init__()
        self.experiment=experiment
        self.allowedValues=allowedValues

    def validate(self,text):
        try:
            value = self.experiment.eval_general(text)
        #check for parsing errors
        except:
            return False
        #check if the value is one of the ones allowed by this particular Enum
        if value not in self.allowedValues:
            return False
        #if we've gotten this far, all tests have passed
        return True

#TODO: make these Fields have validation and able to process statements
enamldef MyIntField(Field):
    """This class exists to make an IntField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = int(text)

enamldef MyFloatField(Field):
    """This class exists to make a FloatField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = float(text)

enamldef MyBoolField(Field):
    """This class exists to make a BoolField (which isn't something that is available anyway),
     that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = bool(text)

enamldef IndexedStack(GroupBox): indexedStack:
    attr iterable=Typed(ListProp)
    attr viewType #=Class(StackItem)  #do we really have to declare what type? I suppose this was so that we would be okay with creating an instance
    hug_height = 'strong'
    hug_width = 'strong'
    
    Container: controls:
        constraints=[hbox(addButton,removeButton,combo)]
        PushButton: addButton:
            text='+'
            constraints=[width==50,height==20]
            clicked::
                iterable.add()
                dyno.refresh_items()
                #dyno.objects.append(viewType(item=iterable.add()))
                combo.maximum=len(iterable)-1
                combo.value=combo.maximum
        PushButton: removeButton:
            text='-'
            constraints=[width==50,height==20]
            clicked::
                i=combo.value
                if i>=0:
                    #dyno.objects.pop(i)
                    iterable.pop(i)
                    dyno.refresh_items()
                    combo.maximum=len(iterable)-1
                    if i>1:
                        combo.value=i-1
                    else:
                        combo.value=0
        # RefreshableComboBox: combo:
            # items<<[str(i)+' '+n.description for i,n in enumerate(iterable)]
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum=len(iterable)-1
            minimum=0
    Stack: stack:
        index<<combo.value
        #Include: dyno:
        #    objects<<[viewType(item=i) for i in iterable]
        Looper: dyno:
            iterable<<indexedStack.iterable
            Include:
                objects=[viewType(item=loop_item)]

enamldef CsMenuBar(MenuBar): menuBar:
    attr experiment
    attr mainWindow
    
    Menu:
        title = '&File'
        Action:
            text = 'Load\tCtrl+L'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Choose file to load',
                    mode='open_file',
                    path=os.path.join('..','settings'), #os.path.abspath(r'C:\Users\Saffmanlab\Documents\CsController2\settings'),
                    callback=get_load_file_callback(experiment),
                    ).open()
        Action:
            text = 'Save\tCtrl+S'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Save As?',
                    mode='save_file',
                    path=os.path.join('..','settings','settings-'+datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')), #os.path.abspath(r'C:\Users\Saffmanlab\Documents\CsController2\settings\settings-'+datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')),
                    callback=get_save_file_callback(experiment),
                    ).open()
        Action:
            text = 'Quit\tCtrl+Q'
            triggered::
                mainWindow.close()
    Menu:
        title = '&Experiment'
        Action:
            text = 'Reset and Run\tCtrl+R'
            triggered::experiment.resetAndGoThread()
        Action:
            text = 'Reset'
            triggered::experiment.resetThread()
        Action:
            text = 'Run'
            triggered::experiment.goThread()
        Menu:
            title = 'Pause...'
            Action:
                checkable = True
                text = 'After Measurement'
                checked := experiment.pauseAfterMeasurement
            Action:
                checkable = True
                text = 'After Iteration'
                checked := experiment.pauseAfterIteration
            Action:
                checkable = True
                text = 'After Error'
                checked := experiment.pauseAfterError
        Action:
            text = 'Continue\tCtrl+G'
            triggered::experiment.goThread()
        Action:
            text = 'Halt\tCtrl+H'
            triggered::experiment.halt()

enamldef EvalProp(GroupBox):
    attr prop
    padding=0
    flat=True
    title<<prop.name
    constraints=[desc.width==func.width,func.width==val.width,hbox(desc,func,val),align('v_center',desc,func,val)]

    Field: desc:
        text:=prop.description
        placeholder='description'
    Field: func:
        text:=prop.function
        placeholder=prop.placeholder
        validator=prop #.validator
        #valid<<prop.valid
    Label: val:
        text<<str(prop.value)
#    CheckBox: check:
#        checked<<prop.valid
#        enabled=False
        
    
enamldef MultilineProp(GroupBox):        
    attr prop
    flat=True
    title:=prop.name
    constraints=[vbox(desc,hbox(func,val)),align('top',func,val)]
    Field: desc:
        text:=prop.description
        placeholder='description'
    MultilineField: func:
        text:=prop.function
    Label: val:
        text<<str(prop.value)

enamldef LabelBox(Container):
    attr checked #=False
    attr text #=''
    
    padding=0
    constraints=[hbox(label,box),align('v_center',label,box)]
    hug_height='strong'
    hug_width='strong'
    Label: label:
        text<<parent.text
    CheckBox: box:
        checked:=parent.checked

enamldef CheckField(Container):
    attr checked=False
    attr text=''
    attr placeholder=''
    
    constraints=[hbox(box,field),align('v_center',box,field)]
    CheckBox: box:
        checked:=parent.checked
    Field: field:
        text:=parent.text
        placeholder:=parent.placeholder

enamldef LabelField(Container):
    attr label=''
    attr text=''
    attr placeholder=''
    
    hug_height='strong'
    hug_width='strong'
    constraints=[vbox(l1,f1),l1.left==f1.left]
    Label: l1:
        text:=parent.label
    Field: f1:
        text:=parent.text
        placeholder:=parent.placeholder

#class RefreshableComboBox(ComboBox):
#    refresh = EnamlEvent

enamldef ExperimentPage(Page):
    attr experiment
    title='Experiment'

    Container:
        Form: form:
            Label:
                text="Status:"
            Label:
                text<<experiment.status

            Label:
                text='Pause after iteration'
            CheckBox:
                checked:=experiment.pauseAfterIteration

            Label:
                text='Pause after measurement'
            CheckBox:
                checked:=experiment.pauseAfterMeasurement
            
            Label:
                text='Pause after error'
            CheckBox:
                checked:=experiment.pauseAfterError
            
            Label: text='Save Data?'
            CheckField:
                checked:=experiment.saveData
                text:=experiment.localDataPath
                placeholder='local data path'
            
            Label: text='Save Settings?'
            CheckBox:
                checked:=experiment.saveSettings
            
            Label: text='Save 2013 style files?'
            CheckBox:
                checked:=experiment.save2013styleFiles

            Label: text='Copy Data to Network?'
            CheckField:
                checked:=experiment.copyDataToNetwork
                text:=experiment.networkDataPath
                placeholder='network data path'

            Label: text='Experiment description suffix for filename'
            Field: text:=experiment.experimentDescriptionFilenameSuffix

            Label: text='Measurement Timeout [s]'
            FloatField: value:=experiment.measurementTimeout

            Label: text='Measurements per Iteration'
            IntField: value:=experiment.measurementsPerIteration
        
            Label: text='E-mail on error/completion?'
            CheckField:
                checked:=experiment.willSendEmail
                text:=experiment.emailAddresses
            
            Label: text='Progress'
            Label: text<<str(experiment.progress)+'%'
            
            Label: text='Iteration'
            Label: text<<str(experiment.iteration)+' of '+str(experiment.totalIterations-1)
            
            Label: text='Measurement'
            Label: text<<str(experiment.measurement)+' of '+str(experiment.measurementsPerIteration-1)
            
            Label: text='Good Measurements'
            Label: text<<str(experiment.goodMeasurements)+' of '+str(experiment.measurementsPerIteration-1)
            
            Label: text='Time started'
            Label: text<<experiment.timeStartedStr
            
            Label: text='Time after last measurement'
            Label: text<<experiment.currentTimeStr
            
            Label: text='Time elapsed'
            Label: text<<experiment.timeElapsedStr

            Label: text='Estimated total time'
            Label: text<<experiment.totalTimeStr

            Label: text='Estimated time remaining'
            Label: text<<experiment.timeRemainingStr

            Label: text='Estimated completion time'
            Label: text<<experiment.completionTimeStr
            
            Label: text='Notes'
            MultilineField:
                text:=experiment.notes

enamldef VariableEntry(GroupBox):
    attr indepVar
    attr myIndependentVariables
    attr myDyno
    
    constraints=[nameCont.width==0.5*descCont.width,descCont.width==funcCont.width,currentValueLabel.right==funcCont.right,vbox(hbox(remove,nameCont,descCont,funcCont),valueListLabel,hbox(stepsLabel,currentValueLabel)),align('v_center',remove,nameCont,descCont,funcCont),align('v_center',stepsLabel,currentValueLabel)]
    
    PushButton: remove:
        text='-'
        clicked::
            #i=myIndependentVariables.index(indepVar) #find current index
            myIndependentVariables.remove(indepVar) #remove from backend list
            myDyno.refresh_items() #refresh GUI
    Field: nameCont:
        text:=indepVar.name
        placeholder='name'
    Field: descCont:
        text:=indepVar.description
        placeholder='description'
    Field: funcCont:
        text:=indepVar.function
        placeholder='function'
    Label: valueListLabel:
        text<<'values: '+indepVar.valueListStr
    Label: stepsLabel:
        text<<'step: '+str(indepVar.index)+' of '+str(indepVar.steps)
    Label: currentValueLabel:
        text<<'current value: '+indepVar.currentValueStr

enamldef IndependentVariablesGroupBox(GroupBox): iVarBox:
    attr experiment
    title='Independent Variables'
    
    initialized::
        experiment.independentVariables.dyno=dyno
    
    PushButton: addbutton:
        text='+'
        clicked::
            newvar=IndependentVariable('new',experiment) #new blank independentVariable
            iVarBox.experiment.independentVariables.append(newvar) #add a new variable to the list
            dyno.refresh_items()
    GroupBox: varlistContainer:
        Looper: dyno:
            iterable<<iVarBox.experiment.independentVariables
            VariableEntry:
                myIndependentVariables=iVarBox.experiment.independentVariables
                indepVar=loop_item
                myDyno=dyno

enamldef VariablesPage(Page): main:
    attr experiment
    title = 'Variables'
    Container:
        Container:
            constraints=[hbox(settings,report),align('top',settings,report)]
            hug_height='strong'
            hug_width='strong'

            Container: settings:
                padding=0
                hug_height='strong'
                hug_width='strong'

                PushButton: updateButton:
                    text='Update variables throughout experiment'
                    clicked::
                        experiment.evaluateAll()
                IndependentVariablesGroupBox: independent:
                    experiment<<main.experiment

                GroupBox: dependent:
                    title='Dependent Variables'
                    constraints=[vbox(lb1,field,variablesNotToSave)]
                    Label: lb1:
                        text='Define dependent variables using python code below.'
                    MultilineField: field:
                        constraints=[height==600]
                        text:=experiment.dependentVariablesStr
                    GroupBox: variablesNotToSave:
                        hug_height='strong'
                        title='Variables Not To Save to HDF5 (comma separated)'
                        Field:
                            text:=experiment.variablesNotToSave
                            placeholder='scipy,numpy,x'
            GroupBox: report:
                title='Report'
                hug_height='strong'
                hug_width='strong'
                constraints=[hbox(f1,lb2),align('top',f1,lb2)]

                MultilineField: f1:
                    constraints=[height==600]
                    text:=experiment.variableReportFormat
                Label: lb2:
                    text<<experiment.variableReportStr

enamldef LabViewPage(Page):
    attr LabView
    title = 'LabView'
    
    Container:
        Container:
            hug_height='strong'
            Container:
                constraints=[hbox(b1,b3,b4),b1.width==100,b3.width==100,b4.width==100]
                PushButton: b1:
                    text='open connection'
                    clicked::
                        LabView.openThread()
                PushButton: b3:
                    text='update settings'
                    clicked::
                        LabView.update()
                PushButton: b4:
                    text='close connection'
                    clicked::
                        LabView.close()

            Form:
                Label:
                    text='enable communication with LabView system?'
                CheckBox:
                    checked:=LabView.enabled
                Label:
                    text='IP address of LabView system'
                Field:
                    text:=LabView.IP
                Label:
                    text='communications port'
                IntField:
                    value:=LabView.port
                Label:
                    text='cycle experiment continuously even when not taking data?'
                CheckBox:
                    checked:=LabView.cycleContinuously
            EvalProp:
                prop<<LabView.timeout
            Form:
                Label:
                    text='connected'
                CheckBox:
                    checked:=LabView.connected
                    enabled=False
                Label: text='LabView error'
                Label: text<<str(LabView.error)
            
            GroupBox:
                title='TCP output message'
                constraints = [vbox(scroller1),(height==500)|'strong']
                hug_width='ignore'
                ScrollArea:scroller1:
                    Container:
                        hug_height='ignore'
                        hug_width='ignore'
                        Label:
                            hug_height='ignore'
                            hug_width='ignore'
                            text<<LabView.msg

            GroupBox:
                title='LabView log'
                constraints = [vbox(scroller2),(height==500)|'strong']
                hug_width='ignore'
                ScrollArea: scroller2:
                    Container:
                        hug_height='ignore'
                        hug_width='ignore'
                        Label:
                            hug_height='ignore'
                            hug_width='ignore'
                            text<<LabView.log

enamldef DOchannel(Container):
    attr channel
    attr index
    hug_height='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel.description
        placeholder='description'
    Field: activeF:
        text:=channel.active.function
        placeholder='active?'
    Label: activeL:
        text<<str(channel.active.value)

enamldef DOchannels(GroupBox):
    attr channels
    flat=True
    title='channels (#, description, active?)'
    
    Looper: looper:
        iterable << channels
        DOchannel:
            channel=loop_item
            index=loop_index

enamldef HSDIOScriptTrigger(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
        EvalProp:
            prop<<item.id
        EvalProp:
            prop<<item.source
        EvalProp:
            prop<<item.type
        EvalProp:
            prop<<item.edge
        EvalProp:
            prop<<item.level

enamldef StartTrigger(GroupBox):
    attr trigger
    title='Start Trigger'
    
    EvalProp:
        prop<<trigger.waitForStartTrigger
    EvalProp:
        prop<<trigger.source
    EvalProp:
        prop<<trigger.edge

enamldef Transition(Container):
    attr transition
    attr waveform
    attr waveformContainer
    
    #constraints=[vbox(remove,form)]
    padding=0
    PushButton: remove:
        constraints = [height==20]
        text='-'
        clicked::
            waveform.sequence.remove(transition) #remove ourselves from the backend
            waveformContainer.itemToRemove=parent #we can't just do the removing from here because once the GUI reference is gone, we get garbage collected and can't trigger the resetting of constraints
            #remove ourselves from the GUI
            waveformContainer.remove = not waveformContainer.remove #TODO: figure out how to do this with a true callable event, rather than signaling with a changed Bool
    Field:
        constraints = [height==20]
        placeholder = 'description'
        text:=transition.description
    Form:
        padding=0
        Field:
            constraints = [width == 100,height==20]
            placeholder='time'
            text:=transition.time.function
            text::waveform.evaluate()
        Label:
            constraints = [width == 50,height==20]
            text<<str(transition.time.value)
        Looper:
            iterable<<transition.state
        #EvalProp:
            #prop<<loop_item
            Field:
                constraints = [width == 100,height==20]
                text:=loop_item.function
                placeholder=loop_item.placeholder #or perhaps use str(loop_index)
                validator=loop_item
                text::waveform.evaluate()
            Label:
                constraints = [width == 50,height==20]
                text<<str(loop_item.value)

class RefreshableMPLCanvas(MPLCanvas):
    """ An MPLCanvas that can be refreshed on command by toggling refresh.
    Requires adding a function to MPLCanvas in
    C:\Users\Saffmanlab\AppData\Local\Enthought\Canopy\User\Lib\site-packages\enaml\qt\qt_mpl_canvas.py:
        def on_action_set_refresh(self, content):
            self.refresh_mpl_widget()
    """
    
    #: Toggle this to refresh the canvas
    refresh = d_(Bool())

class RemoveEventContainer(Container):
    remove=d_(Bool())

enamldef Waveform(RemoveEventContainer): thisWaveformContainer:
    attr waveform
    attr itemToRemove
    hug_height='strong'
    hug_width='ignore'
    
    constraints=[canvas.left==details.left,vertical(canvas,details)]
    
    remove::
        dyno.objects.remove(itemToRemove)
        transitions.constraints=[hbox(*dyno.objects)] if len(dyno.objects)>0 else []
        waveform.evaluate()
    #Container:
    #uncomment me!
    #constraints=[vbox(canvas,details)]
    # PushButton: updateCanvas:
        # text='update graph'
        # clicked::
            # waveform.updateFigure()
    
    #the following 7 lines are used for the matplotlib digital waveform plot 
    MPLCanvas: canvas:
        constraints=[(height==500)|'strong',(width==1500)|'strong']
        #hug_width='ignore'
        figure << waveform.figure
        #refresh<<waveform.refresh
    
    #the following 6 lines would be used for the Chaco digital waveform plot
    #constraints=[vbox(canvas,details)]
    #EnableCanvas: canvas:
    #    # TODO: make this expand and shrink nicely while filling the width
    #    hug_width='ignore'
    #    constraints=[height==500]
    #    component<<waveform.component
    
    Container: details:
        #constraints=[nameAndChannelNums.top==contents_top,transitions.top==contents_top,addButton.top==contents_top,nameAndChannelNums.left==contents_left,
        #    nameAndChannelNums.right==transitions.left,transitions.right==addButton.left]
        constraints=[hbox(nameAndChannelNums,transitions,addButton),addButton.top==transitions.top]
        hug_height='strong'
        hug_width='strong'
        Container: nameAndChannelNums:
            #constraints=[vbox(f1,l1,loop1)]
            padding=0
            Field: f1:
                constraints = [width == 150, height == 20]
                text:=waveform.name
            Label:
                constraints = [height == 20]
                text='description'                
            Label: l1:
                constraints = [height == 20]
                text='time'
            Looper: loop1:
                iterable<<range(waveform.digitalout.numChannels)
                Label:
                    constraints=[height==20]
                    text<<str(loop_index)+': '+waveform.experiment.LabView.HSDIO.channels[loop_index].description
        Container: transitions:
            padding=0
            #constraints=gen_constraints(dyno.objects)
            #constraints=[grid(dyno.objects,row_align='top')]
            constraints=[hbox(*dyno.objects)] if len(dyno.objects)>0 else []
            Include: dyno:
                objects=[Transition(transition=i,waveform=waveform,waveformContainer=thisWaveformContainer) for i in waveform.sequence]
        PushButton: addButton:
            #add a transition to this waveform
            constraints = [width == 50, height == 20]
            text='+'
            clicked::
                dyno.objects.append(Transition(transition=waveform.addTransition(),waveform=waveform,waveformContainer=thisWaveformContainer))
                transitions.constraints=[hbox(*dyno.objects)] if len(dyno.objects)>0 else []
                #transitions.constraints=[grid(dyno.objects,row_align='top')]
                #transitions.constraints=gen_constraints(dyno.objects)
                waveform.evaluate()

enamldef NumpyDOchannel(Container):
    attr channel
    attr index
    attr digitalout #the DAQmxDO or HSDIO
    attr experiment

    hug_height='strong'
    hug_width='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel['description']
        placeholder='description'
    Field: activeF:
        text:=channel['function']
        placeholder='active?'
        validator<<MyBoolValidator(experiment)
        text::
            channel['value']=experiment.eval_bool(text)
            activeL.text=str(channel['value']) #must be updated manually because the channel['value'] identity does not change
            digitalout.evaluate()
    Label: activeL:
        text<<str(channel['value'])

enamldef NumpyDOchannels(GroupBox):
    attr channels
    title='channels (#, description, active?)'
    hug_height='strong'
    hug_width='strong'
    #constraints=[controls.left==dynoCont.left]
    Container: controls:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton,removeButton)]
        SpinBox: spin0:
            minimum=0
            maximum<<len(channels.array)
        PushButton: addButton:
            text='+'
            clicked::
                channels.add(spin0.value)
        PushButton: removeButton:
            text='-'
            clicked::
                channels.remove(spin0.value)
    Container: dynoCont:
        Include: dyno:
            objects<<[NumpyDOchannel(channel=x,index=i,digitalout=channels.digitalout,experiment=channels.experiment) for i,x in enumerate(channels.array)]

enamldef NumpyState(Form):
    attr state
    attr experiment
    attr waveform

    padding=0

    Field:
        constraints = [width == 100,height==20]
        #placeholder='state: None,0,1'
        text:=state['function']
        validator<<MyEnumValidator(experiment,[None,0,1])
        text::
            temp=experiment.eval_general(text)
            if temp is None:
                state['value']=5
                valueLabel.text=''
            else:
                state['value']=temp
                valueLabel.text=str(state['value']) #must be updated manually because state['value'] identity does not change
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width == 50,height==20]
        text<<('' if state['value']==5 else str(state['value']))

enamldef ChannelCombo(ComboBox):
    attr wfm
    attr channels
    attr channelList
    attr position
    
    items<<[str(i)+' '+x for i,x in enumerate(channels.array['description'])]
    index<<int(channelList[position])
    index::
        channelList[position]=numpy.uint8(index)
        wfm.updateFigure()

enamldef TransitionsLabel(Container):
    padding=0
    Label:
        constraints = [height == 20]
        text='description'
    Label:
        constraints = [height == 20]
        text='time'

enamldef DescriptionLabel(Label):
    constraints = [height == 20]
    text='description'
    
enamldef TimeLabel(Label):
    constraints = [height == 20]
    text='time'

enamldef TransitionDescription(Field):
    attr transition
    constraints = [height==20]
    placeholder = 'description'
    text:=transition['description']

enamldef TransitionTime(Form):
    attr experiment
    attr waveform
    attr transition
    
    padding=0
    
    Field:
        constraints = [width == 100,height==20]
        placeholder='time'
        text:=transition['function']
        validator<<MyFloatValidator(experiment)
        text::
            transition['value']=experiment.eval_float(text)
            valueLabel.text='{:.6f}'.format(transition['value']) #must be updated manually because transition['value'] identity does not change
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width == 50,height==20]
        text<<'{:.6f}'.format(transition['value'])

enamldef NumpyWaveform(Container):
    attr waveform
    
    hug_height='strong'
    hug_width='ignore'
    constraints=[vbox(plotcontrols,details),align('left',plotcontrols,details)] #for some reason this makes the canvas disappear
    
    #MPLCanvas: canvas:
    #    constraints=[(height==500)|'strong',(width==1500)|'strong']
    #    figure << waveform.figure
    
    Container: plotcontrols:
        hug_width='strong'
        hug_height='strong'
        constraints=[hbox(lmin,plotmin,lmax,plotmax)]        
        padding=0
        Label: lmin:
            text='plot min'
        Field: plotmin:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmin=-1
                else:
                    waveform.plotmin=float(text)
                waveform.updateFigure()
        Label: lmax:
            text='plot max'
        Field: plotmax:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmax=-1
                else:
                    waveform.plotmax=float(text)
                waveform.updateFigure()
    
    Container: details:
        constraints=[vbox(hbox(nameField,timeControls,channelControls),transitions)]
        hug_height='strong'
        hug_width='strong'

        Field: nameField:
            constraints = [width == 150, height == 20]
            text:=waveform.name

        GroupBox: timeControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l0,spin0,addButton0,removeButton0)]
            Label: l0:
                text='times'
            SpinBox: spin0:
                minimum=0
                maximum<<len(waveform.transitions.array)
            PushButton: addButton0:
                text='+'
                clicked::
                    waveform.addTransition(spin0.value)
            PushButton: removeButton0:
                text='-'
                clicked::
                    waveform.removeTransition(spin0.value)

        GroupBox: channelControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l1,spin1,addButton1,removeButton1)]
            Label: l1:
                text='channels'
            SpinBox: spin1:
                minimum=0
                maximum<<len(waveform.channelList)
            PushButton: addButton1:
                text='+'
                clicked::
                    waveform.addChannel(spin1.value)
            PushButton: removeButton1:
                text='-'
                clicked::
                    waveform.removeChannel(spin1.value)
        GroupBox: transitions:
            hug_height='strong'
            hug_width='strong'
            title='waveform transition and sequence (valid states: blank(None),0,1)'
            constraints<<[grid(*[statesDyno.objects[i:(i+len(waveform.transitions.array)+1)] for i in range(0, len(statesDyno.objects), len(waveform.transitions.array)+1)])] if len(statesDyno.objects)>0 else []
            Include: statesDyno:
                objects<<[DescriptionLabel()]+[TransitionDescription(transition=t) for t in waveform.transitions.array]+[TimeLabel()]+[TransitionTime(transition=t,experiment=waveform.experiment,waveform=waveform) for t in waveform.transitions.array]+(list(itertools.chain(*map(list,zip(*([[ChannelCombo(wfm=waveform,channels=waveform.digitalout.channels,channelList=waveform.channelList,position=i) for i in xrange(len(waveform.channelList))]]+[[NumpyState(state=s,experiment=waveform.experiment,waveform=waveform) for s in waveform.sequence.array.flat][i:i+len(waveform.channelList)] for i in range(0,waveform.sequence.array.size,len(waveform.channelList))]))))) if (len(waveform.channelList)>0) else [])

enamldef WaveformPage(Page):
    attr waveform
    
    title<<waveform.name
    closed::waveform.remove()
    
    NumpyWaveform:
        waveform<<parent.waveform

enamldef WaveformStackItem(StackItem):
    attr item
    NumpyWaveform:
        waveform<<item

def get_load_waveform_callback(HSDIO):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                HSDIO.importWaveform(dlg.path)
            except PauseError:
                pass
    return load_file_callback

enamldef WaveformsPage(Page):
    attr HSDIO
    title='Waveforms'
    
    Container:
        Container:
            hug_height='strong'
            hug_width='strong'
            constraints=[vbox(buttons,canvas,stack),align('left',buttons,canvas,stack)]
            Container: buttons:
                constraints=[hbox(combo,importWaveform,addWaveform,removeWaveform,copyWaveform)]
                hug_height='strong'
                hug_width='strong'
                ComboBox: combo:
                    constraints=[(width==500)|'strong']
                    items=[i.name for i in HSDIO.waveforms]
                PushButton: importWaveform:
                    #add a waveform from a file
                    text='import'
                    clicked::
                        dlg = FileDialog(
                            parent=importWaveform,
                            title='Choose file to load waveform from',
                            mode='open_file',
                            path=os.path.join('..','settings'),
                            callback=get_load_waveform_callback(HSDIO),
                            ).open()
                        dyno.refresh_items()
                        combo.items=[i.name for i in HSDIO.waveforms]
                        combo.index=len(HSDIO.waveforms)-1
                PushButton: addWaveform:
                    constraints=[(width==50)|'strong']
                    text = 'add'
                    clicked::
                        HSDIO.waveforms.add()
                        dyno.refresh_items()
                        combo.items=[i.name for i in HSDIO.waveforms]
                        combo.index=len(HSDIO.waveforms)-1
                PushButton: removeWaveform:
                    constraints=[(width==50)|'strong']
                    text = 'remove'
                    clicked::
                        i=combo.index
                        if i>=0:
                            HSDIO.waveforms.pop(i)
                            dyno.refresh_items()
                            if i>1:
                                combo.index=i-1
                            else:
                                combo.index=0
                        combo.items=[i.name for i in HSDIO.waveforms]
                PushButton: copyWaveform:
                    constraints=[(width==50)|'strong']
                    text = 'copy'
                    clicked::
                        HSDIO.waveforms.copy(combo.index)
                        dyno.refresh_items()
                        combo.items=[i.name for i in HSDIO.waveforms]
                        combo.index=len(HSDIO.waveforms)-1
            MPLCanvas: canvas:
                constraints=[(height==500)|'strong',(width==1500)|'strong']
                figure << HSDIO.waveforms[combo.index].figure
            Stack: stack:
                index<<combo.index
                Looper: dyno:
                    iterable<<HSDIO.waveforms
                    WaveformStackItem:
                            item=loop_item
            #NumpyWaveform: stack:
            #    waveform<<HSDIO.waveforms[combo.index]

enamldef HSDIO_DigitalOutPage(Page):
    attr HSDIO
    title = 'HSDIO Pulses'

    Container:
        Container:
                constraints=[hbox(vbox(p1,p9,p2,p4,p5,p6,p7,p8),p3),align('left',p1,p9,p2,p4,p5,p6,p7),align('top',p1,p3)]
                hug_height='strong'
                hug_width='strong'
                EvalProp: p1:
                    prop<<HSDIO.enable
                StartTrigger: p9:
                    trigger<<HSDIO.startTrigger
                IndexedStack: p2:
                    title='Script Triggers'
                    iterable=HSDIO.triggers
                    viewType=HSDIOScriptTrigger
                MultilineProp: p3:
                    prop<<HSDIO.script
                EvalProp: p4:
                    prop<<HSDIO.resourceName
                EvalProp: p5:
                    prop<<HSDIO.clockRate
                EvalProp: p6:
                    prop<<HSDIO.units
                EvalProp: p7:
                    prop<<HSDIO.hardwareAlignmentQuantum
                NumpyDOchannels: p8:
                    channels<<HSDIO.channels

enamldef DAQmxDigitalOutPage(Page):
    title = 'DAQmx DO'    
    attr DAQmx
    
    Container:
        Container:
                constraints=[vbox(canvas,p6,hbox(vbox(p0,p1,p2,p3,p4),p5)),align('top',p0,p5)]
                hug_height='strong'
                hug_width='strong'
                EvalProp: p0:
                    prop<<DAQmx.enable
                EvalProp: p1:
                    prop<<DAQmx.resourceName
                EvalProp: p2:
                    prop<<DAQmx.clockRate
                EvalProp: p3:
                    prop<<DAQmx.units
                StartTrigger: p4:
                    trigger<<DAQmx.startTrigger
                NumpyDOchannels: p5:
                    channels<<DAQmx.channels
                NumpyWaveform: p6:
                    waveform<<DAQmx.waveform
                MPLCanvas: canvas:
                    constraints=[(height==500)|'strong',(width==1500)|'strong']
                    figure << DAQmx.waveform.figure

enamldef DDS_profile(StackItem):
    attr profile
    
    Container:
        hug_height='strong'
        hug_width='strong'
        padding=0
        Container:
            padding=0
            hug_height='strong'
            hug_width='strong'
            constraints=[vbox(description,hbox(container1,container2))]
            Form: description:
                Label:
                    text='description'
                Field:
                    placeholder='description'
                    text:=profile.description
            Container: container1:
                hug_height='strong'
                hug_width='strong'
                EvalProp:
                    prop<<profile.frequency
                EvalProp:
                    prop<<profile.amplitude
                EvalProp:
                    prop<<profile.phase
                EvalProp:
                    prop<<profile.RAMMode
                EvalProp:
                    prop<<profile.ZeroCrossing
                EvalProp:
                    prop<<profile.NoDwellHigh
                EvalProp:
                    prop<<profile.FunctionOrStatic
            Container: container2:
                hug_height='strong'
                hug_width='strong'
                EvalProp:
                    prop<<profile.RAMFunction
                EvalProp:
                    prop<<profile.RAMInitialValue
                EvalProp:
                    prop<<profile.RAMStepValue
                EvalProp:
                    prop<<profile.RAMTimeStep
                EvalProp:
                    prop<<profile.RAMNumSteps
                IndexedStack:
                    title='RAMStaticArray'
                    iterable<<profile.RAMStaticArray
                    viewType=ItemProp

enamldef ItemProp(StackItem):
    attr item
    
    Container:
        padding=0
        EvalProp:
            prop<<item
                
enamldef DDS_channel(GroupBox):
    attr channel
    attr index
    
    title='channel '+str(index)
    constraints=[hbox(vbox(parameters,RAM),profiles)]
    
    GroupBox: parameters:
        title='channel parameters'
        flat=True
        constraints=[vbox(description,power,refClockRate,fullScaleOutputPower)]
        Form: description:
            Label:
                text='description'
            Field:
                text:=channel.description
        EvalProp: power:
            prop<<channel.power
        EvalProp: refClockRate:
            prop<<channel.refClockRate
        EvalProp: fullScaleOutputPower:
            prop<<channel.fullScaleOutputPower
    
    GroupBox: RAM:
        title='RAM defaults'
        flat=True
        EvalProp:
            prop<<channel.RAMenable
        EvalProp:
            prop<<channel.RAMDestType
        EvalProp:
            prop<<channel.RAMDefaultFrequency
        EvalProp:
            prop<<channel.RAMDefaultAmplitude
        EvalProp:
            prop<<channel.RAMDefaultPhase

    GroupBox: profiles:
        title='profiles'
        hug_height='strong'
        hug_width='strong'
        ComboBox: combo:
            items<<list(channel.profileDescriptionList)
        Stack:
            index<<combo.index
            #Include: dyno:
            #    objects<<[DDS_profile(profile=i) for i in channel.profiles]
            Looper:
                iterable<<channel.profiles
                DDS_profile:
                    profile=loop_item
    
enamldef DDS_box(StackItem):
    attr box
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=box.enable
            
            Label:
                text='Description'
            Field:
                text:=box.description
                
            PushButton:
                text='select USB device reference'
                clicked::
                    box.deviceReference=combo.selected_item.strip()
            ComboBox: combo:
                items<<list(box.DDS.deviceList)
                
            Label:
                text='NI USB-8451 device reference'
            Field:
                pass
                text:=box.deviceReference
            
            Label:
                text='DIO port'
            SpinBox: sbox:
                #maximum = maxint
                maximum = 999999
                minimum = 0
                value:=box.DIOport
            Label:
                text='serialClockRate'
            IntField:
                value:=box.serialClockRate  # THIS LINE IS THE PROBLEM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        GroupBox:
            hug_height='strong'
            hug_width='strong'
            title='channels'
            #Include: dyno:
            #    objects<<[DDS_channel(index=i,channel=c) for i,c in enumerate(box.channels)]
            Looper:
                iterable<<box.channels
                DDS_channel:
                    index<<loop_index
                    channel<<loop_item

enamldef DDS_Page(Page): page:
    attr DDS
    title = 'DDS'
    
    Container:
        Container:
            hug_width='strong'
            hug_height='strong'
            constraints=[vbox(hbox(enable,isInit,getDevicesButton,initButton,loadButton),stackGroup),align('v_center',getDevicesButton,initButton,loadButton,enable,isInit),enable.width==500,getDevicesButton.width==200,initButton.width==200,loadButton.width==200]
            EvalProp: enable:
                        prop<<DDS.enable
            PushButton: getDevicesButton:
                text='Get DDS Device List'
                clicked::DDS.getDDSDeviceList()
            PushButton: initButton:
                text='Initialize and Load'
                clicked::DDS.initializeDDS()
            PushButton: loadButton:
                text='Load'
                clicked::DDS.loadDDS()

            #LabelBox: enable:
            #    text='enable'
            #    checked:=DDS.enable.value
            
            LabelBox: isInit:
                text='initialized?'
                checked<<DDS.isInitialized
                enabled=False #keep it greyed out.
            
            GroupBox: stackGroup:
                pass
                title='DDS boxes'
                constraints=[vbox(hbox(combo,addButton,removeButton),stack),stack.width==contents_width]
                ComboBox: combo:
                    items<<list(DDS.boxDescriptionList)
                PushButton: addButton:
                    text='+'
                    constraints=[width==50,height==20]
                    clicked::
                        DDS.addBox()
                        dyno.refresh_items()
                        DDS.updateBoxDescriptionList()
                        combo.index=len(DDS.boxes)-2 #point to new box
                PushButton: removeButton:
                    text='-'
                    constraints=[width==50,height==20]
                    clicked::
                        i=combo.index
                        if i>=0:
                            DDS.boxes.pop(i)
                            dyno.refresh_items()
                            DDS.updateBoxDescriptionList()
                            combo.index=i-1
                Stack: stack:
                    index<<combo.index
                    Looper: dyno:
                        iterable<<DDS.boxes
                        pass
                        DDS_box:
                            box=loop_item

enamldef RF_gen(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            Label:
                text='description'
            Field:
                text:=item.description
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power

enamldef HP83623A(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            
            Label:
                text='description'
            Field:
                text:=item.description
            
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power
        EvalProp:
            prop<<item.RFoutput
        EvalProp:
            prop<<item.externalTrigger

enamldef RFGenPage(Page):
    attr LabView
    title = 'RF Generators'
    Container:
        EvalProp:
            prop<<LabView.RF_generators.enable
        IndexedStack: i1:
            title='HP83623A'
            iterable=LabView.RF_generators.HP83623A_list
            viewType=HP83623A
        IndexedStack: i2:
            title='HP8662A'
            iterable=LabView.RF_generators.HP8662A_list
            viewType=RF_gen
        IndexedStack: i3:
            title='HP83712B'
            iterable=LabView.RF_generators.HP83712B_list
            viewType=RF_gen

enamldef CameraPage(Page):
    attr camera
    title = 'Camera'
    Container:
        Container:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<camera.enable
            EvalProp:
                prop<<camera.saveAsPNG
            EvalProp:
                prop<<camera.saveAsASCII
            EvalProp:
                prop<<camera.forceImagesToU16
            EvalProp:
                prop<<camera.EMGain
            EvalProp:
                prop<<camera.analogGain
            EvalProp:
                prop<<camera.exposureTime
            EvalProp:
                prop<<camera.scanSpeed
            EvalProp:
                prop<<camera.lowLightSensitivity
            EvalProp:
                prop<<camera.externalTriggerMode
            EvalProp:
                prop<<camera.triggerPolarity
            EvalProp:
                prop<<camera.externalTriggerSource
            EvalProp:
                prop<<camera.cooling
            EvalProp:
                prop<<camera.fan
            EvalProp:
                prop<<camera.scanMode
            EvalProp:
                prop<<camera.photoelectronScaling
            EvalProp:
                prop<<camera.subArrayLeft
            EvalProp:
                prop<<camera.subArrayTop
            EvalProp:
                prop<<camera.subArrayWidth
            EvalProp:
                prop<<camera.subArrayHeight
            EvalProp:
                prop<<camera.superPixelBinning
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionLeft
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionTop
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionRight
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionBottom
            EvalProp:
                prop<<camera.numImageBuffers
            EvalProp:
                prop<<camera.shotsPerMeasurement

enamldef CounterPage(Page):
    title = 'Counter'

enamldef FiltersPage(Page):
    title = 'Filters'

enamldef AOequation(StackItem):
    attr item
    Container:
        hug_height='strong'
        hug_width='strong'
        GroupBox:
            flat=True
            title='description'
            Field:
                constraints=[width==500]
                text:=item.description
                placeholder='description'
        GroupBox:
            flat=True
            title='function'
            Field:
                constraints=[width==500]
                text:=item.function
                placeholder='function that evaluates to a 1D array, where t will be replaced with AO.timesteps'

enamldef AnalogOutputPage(Page):
    attr AO
    title = 'Analog output'
    Container:
        hug_height='strong'
        #hug_width='strong'
        constraints=[vbox(e1,canvas,equations,c1),align('left',e1,canvas,equations,c1)]
        #constraints=[vbox(e1,equations,c1),align('left',e1,equations,c1)]
        LabelBox: e1:
            text='enable'
            checked:=AO.enable
        #the following 4 lines are for chaco plotting
        #EnableCanvas: canvas:
        #    #TODO: make this expand and shrink nicely while filling the width
        #    constraints=[height==500,width==1500]
        #    component<<AO.plot
        #the following lines are for MPL plotting
        MPLCanvas: canvas:
            constraints=[(height==500)|'strong']
            hug_width='ignore'
            figure << AO.figure
            #refresh << AO.refresh
        IndexedStack: equations:
            title='equations'
            iterable=AO.equations
            viewType=AOequation
        Container: c1:
            hug_height='strong'
            hug_width='strong'
            constraints=[grid([e2,e3,e4],[e5,e6,e7],[e8,e9,e10],[e11,e12])]
            EvalProp: e2:
                prop<<AO.physicalChannels
            EvalProp: e3:
                prop<<AO.minimum
            EvalProp: e4:
                prop<<AO.maximum
            EvalProp: e5:
                prop<<AO.clockRate
            EvalProp: e6:
                prop<<AO.units
            EvalProp: e7:
                prop<<AO.totalAOTime
            EvalProp: e8:
                prop<<AO.waitForStartTrigger
            EvalProp: e9:
                prop<<AO.triggerSource
            EvalProp: e10:
                prop<<AO.triggerEdge
            EvalProp: e11:
                prop<<AO.exportStartTrigger
            EvalProp: e12:
                prop<<AO.exportStartTriggerDestination

enamldef PiezoChannel(Container):
    attr channel
    
    hug_height = 'strong'
    hug_width = 'strong'
    constraints=[hbox(description, setServo,setPosition,label)]
    Field: description:
        placeholder='description'
        text:=channel.description
    EvalProp: setServo:
        prop<<channel.setServo
    EvalProp: setPosition:
        prop<<channel.setPosition
    GroupBox: label:
        flat=True
        title='read from piezo'
        Label:
            text<<'axis:{}\tservo:{}\tposition:'.format(channel.readAxis,channel.readServo,channel.readPosition)

enamldef PiezoController(StackItem):
    attr item
    
    Container:
        hug_height = 'strong'
        hug_width = 'strong'
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
            Label:
                text='enable'
            CheckBox:
                checked::item.enable
            Label:
                text='serial number set:'
            Field:
                placeholder='serial number'
                text:=item.serialNumber
            Label:
                text='id:'
            Label:
                text:=item.identificationRead
            Label:
                text='serial number read:'
            Label:
                text:=item.serialNumberRead
        Looper:
            iterable<<item.channels
            PiezoChannel:
                channel=loop_item

enamldef PI_PiezoPage(Page):
    attr piezo
    title = 'PI Piezo'
    Container:
        LabelBox:
            text='enable'
            checked:=piezo.enable
        IndexedStack:
            title='Piezo Controllers'
            iterable=piezo.controllers
            viewType=PiezoController

enamldef PicomotorPage(Page):
    title = 'Picomotor'

enamldef AnalysisImage(Container):
    attr analysis
    
    padding=0
    constraints=[(height==600)|'strong',(width==600)|'strong']
    MPLCanvas:
        constraints=[(height==600)|'strong',(width==600)|'strong']
        figure<<analysis.figure


enamldef MultiImagePage(Page): page:
    title='Images'
    attr experiment
    attr analysis0
    attr analysis1
    attr analysis2
    attr analysis3

    Container:
        constraints=[vbox(l0,hbox(a0,a1,a2)),align('top',a0,a1,a2)]
        
        Label: l0:
            text<<analysis3.text

        Container: a0:
            hug_height = 'strong'
            hug_width = 'strong'
            AnalysisImage:
                analysis<<analysis0
            Form:
                Label:
                    text = 'Show ROIs?'
                CheckBox:
                    checked := analysis0.showROIs
                Label:
                    text = 'shot'
                SpinBox:
                    minimum=0
                    value := analysis0.shot

        Container: a1:
            hug_height='strong'
            hug_width='strong'
            AnalysisImage:
                analysis<<analysis1
            Form:
                Label:
                   text='Show ROIs?'
                CheckBox:
                    checked:=analysis1.showROIs
            GroupBox:
                hug_height='strong'
                hug_width='strong'
                Looper:
                    iterable << analysis1.ivarNames
                    Form:
                        Label:
                            text=loop_item
                        ComboBox:
                            items=[str(i) for i in analysis1.ivarValueLists[loop_index]]
                            index::
                                analysis1.setIteration(loop_index, index) #send which ivar (loop_index) to update to index
                Form:
                    Label:
                        text='Measurement'
                    SpinBox:
                        minimum=0
                        maximum=9999999 #a big number
                        value:=analysis1.measurement
                Form:
                    Label:
                        text='Shot'
                    SpinBox:
                        minimum=0
                        maximum=9999999 #a big number
                        value:=analysis1.shot
        Container: a2:
            hug_height = 'strong'
            hug_width = 'strong'
            AnalysisImage:
                analysis<<analysis2
            Form:
                Label:
                   text='Show ROIs?'
                CheckBox:
                    checked:=analysis2.showROIs
                Label:
                    text = 'shot'
                SpinBox:
                    minimum=0
                    value := analysis2.shot


enamldef SquareROI(Container):
    attr item
    attr num
    hug_height='strong'
    hug_width='strong'
    constraints=[hbox(l0,f0,f1,f2,f3,f4)]
    Label: l0:
        text=str(num)
    MyIntField: f0:
        placeholder='left'
        value:=item[0]
    MyIntField: f1:
        placeholder='top'
        value:=item[1]
    MyIntField: f2:
        placeholder='right'
        value:=item[2]
    MyIntField: f3:
        placeholder='bottom'
        value:=item[3]
    MyFloatField: f4:
        placeholder='threshold'
        value:=item[4]

enamldef ROIPage(Page):
    attr experiment
    attr analysis
    
    title='ROI'
    
    Container:
        hug_height='ignore'
        hug_width='ignore'
        constraints=[hbox(dynoCont,canvas),align('top',dynoCont,canvas)]
        Container: dynoCont:
            Include: dyno:
                objects<<[SquareROI(item=x,num=i) for i,x in enumerate(analysis.ROIs)]
        MPLCanvas: canvas:
            constraints=[(height==1000)|'strong',(width==1000)|'strong']
            hug_width='ignore'
            figure<<analysis.figure

enamldef HistogramPage(Page):
    attr experiment
    attr analysis

    title = 'Histogram'
    Container:
        hug_height='ignore'
        hug_width='ignore'
        Form:
            Label:
                text = 'shot'
            SpinBox:
                value := analysis.shot
                minimum = 0
                maximum << experiment.LabView.camera.shotsPerMeasurement.value
            Label:
                text = 'roi'
            SpinBox:
                value := analysis.roi
                minimum = 0
                maximum << len(experiment.squareROIAnalysis.ROIs)
        MPLCanvas:
            constraints=[(height==1000)|'strong',(width==1000)|'strong']
            #hug_width='ignore'
            figure<<analysis.figure

enamldef MeasurementsGraphPage(Page):
    attr experiment
    attr analysis
    title = 'Measurements Graph'

    Container:
        hug_height='ignore'
        hug_width='ignore'
        Form:
            Label:
                text = 'shot'
            SpinBox:
                value := analysis.shot
                minimum = 0
                maximum << experiment.LabView.camera.shotsPerMeasurement.value
            Label:
                text = 'roi'
            SpinBox:
                value := analysis.roi
                minimum = 0
                maximum << len(experiment.squareROIAnalysis.ROIs)
        PushButton:
            text = 'clear'
            clicked::analysis.clear()
        MPLCanvas:
            constraints=[(height==1000)|'strong',(width==1000)|'strong']
            figure<<analysis.figure

enamldef OptimizerPage(Page):
    attr experiment
    attr analysis
    title='Optimization'
    
    Form:
        Label:
            text='cost function'
        MultilineField:
            constraints=[height==600]
            text:=experiment.optimizer.costfunction
        
        Label:
            text='update method'
        ComboBox:
            items=['Nelder-Mead','genetic','gradient descent']
        
        MPLCanvas: canvas:
            constraints=[(height==1000)|'strong',(width==1000)|'strong']
            hug_width='ignore'
            figure<<analysis.figure

enamldef Main(MainWindow): main:
    attr experiment
    
    title='Saffmanlab experiment controller'
    initial_position=(0,0)
    initial_size=(1500,1100)
    #icon_source='icon://myicons/atom_loading'
    
    CsMenuBar:
        experiment=main.experiment
        mainWindow=main
    Container:
        padding = 0
        ScrollArea:
            Container:
                hug_height='strong'
                hug_width='strong'
                constraints=[vbox(infobar,notebook),align('left',infobar,notebook)]
                Container: infobar:
                    constraints=[hbox(status,progress)]
                    hug_width='strong'
                    hug_height='strong'
                    Label: status:
                        text<<'Status: {}, Iteration: {}, Measurement: {}, Good Measurements: {}, Progress: {}'.format(experiment.status,str(experiment.iteration)+' of '+str(experiment.totalIterations-1),str(experiment.measurement),str(experiment.goodMeasurements)+' of '+str(experiment.measurementsPerIteration-1),str(experiment.progress))
                    ProgressBar: progress:
                        constraints=[width==1200]
                        minimum=0
                        maximum=100
                        value<<int(experiment.progress)
                Notebook: notebook:
                    tabs_closable=False
                    tabs_movable=False
                    tab_style = 'preferences'
                    ExperimentPage:
                        experiment=main.experiment
                    VariablesPage:
                        experiment=main.experiment
                    LabViewPage:
                        LabView=main.experiment.LabView
                    HSDIO_DigitalOutPage:
                        HSDIO=main.experiment.LabView.HSDIO
                    #HSDIO_DigitalOutPage:
                    #    HSDIO=main.experiment.LabView.HSDIO2
                    WaveformsPage:
                        HSDIO=main.experiment.LabView.HSDIO
                    DAQmxDigitalOutPage:
                        DAQmx=main.experiment.LabView.DAQmxDO
                    DDS_Page:
                        DDS=main.experiment.LabView.DDS
                    RFGenPage:
                        LabView=main.experiment.LabView
                    CameraPage:
                        camera=main.experiment.LabView.camera
                    #CounterPage:
                    #    pass
                    AnalogOutputPage:
                        AO=main.experiment.LabView.AnalogOutput
                    PI_PiezoPage:
                        piezo=main.experiment.LabView.piezo
                    MultiImagePage:
                        experiment=main.experiment
                        analysis0=main.experiment.recent_shot_analysis
                        analysis1=main.experiment.shotBrowserAnalysis
                        analysis2=main.experiment.imageSumAnalysis
                        analysis3=main.experiment.text_analysis
                    ROIPage:
                        experiment=main.experiment
                        analysis=main.experiment.squareROIAnalysis
                    HistogramPage:
                        experiment=main.experiment
                        analysis=main.experiment.histogramAnalysis
                    MeasurementsGraphPage:
                       experiment=main.experiment
                       analysis=main.experiment.measurements_graph
                    OptimizerPage:
                        experiment=main.experiment
                        analysis=main.experiment.optimizer
