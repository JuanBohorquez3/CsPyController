"""
author = 'Martin Lichtman'
created = 2013-04-02
modified >= 2014-04-21

cs_GUI.enaml

A GUI for the Cs experiment controller, written using the enaml toolkit for python.
"""

from __future__ import division
__author__ = 'Martin Lichtman'
import logging
logger = logging.getLogger(__name__)

from cs_errors import PauseError

from enaml.layout.api import vbox, hbox, align, horizontal, vertical, spacer, grid
from enaml.widgets.api import (MainWindow, MenuBar, Menu, Action,
                                Notebook, Page, Container, GroupBox, 
                                Form, Label, CheckBox, SpinBox, PushButton, MPLCanvas,
                                MultilineField, ProgressBar, ScrollArea, Separator,
                                FileDialog,Window, StatusBar, StatusItem,
                                Stack, StackItem, ComboBox, HGroup
)
from enaml.icon import Icon, IconImage
from enaml.image import Image
from enaml.core.declarative import d_
from enaml.core.include import Include
from enaml.stdlib.fields import FloatField, IntField
from enaml.core.api import Looper, Conditional
from enaml.styling import StyleSheet, Style, Setter
from enaml.validator import Validator
from atom.api import Member, Bool, Typed, observe, Callable
import threading, datetime, time, os, itertools
import numpy, itertools

from experiments import IndependentVariable
from instrument_property import ListProp

# redefine Field so that all Fields will have status_tips
from enaml.widgets.api import Field as OldField
enamldef Field(OldField):
    status_tip << text

enamldef MyStyleSheet(StyleSheet):
    Style:
        style_class = 'invalid'
        Setter:
            field = 'background-color'
            value = 'pink'
        Setter:
            field = 'border-color'
            value = 'red'
        Setter:
            field = 'border-style'
            value = 'solid'
        Setter:
            field = 'border-width'
            value = '2'
    Style:
        style_class = 'valid'

enamldef RefreshableLooper(Looper): self:
    """A Looper that sends a reference of itself to the backend controller, so it can be forcibly updated using the
    refresh_items() method."""
    initialized::
        iterable.gui = self

class MyBoolValidator(Validator):
    experiment=Member()

    def __init__(self,experiment):
        super(MyBoolValidator,self).__init__()
        self.experiment=experiment

    def validate(self,text):
        try:
            value = self.experiment.eval_bool(text)
        except:
            return False
        return True


class MyEnumValidator(Validator):
    experiment=Member()
    allowedValues=Member()

    def __init__(self,experiment,allowedValues):
        super(MyEnumValidator,self).__init__()
        self.experiment=experiment
        self.allowedValues=allowedValues

    def validate(self,text):
        try:
            value = self.experiment.eval_general(text)
        #check for parsing errors
        except:
            return False
        #check if the value is one of the ones allowed by this particular Enum
        if value not in self.allowedValues:
            return False
        #if we've gotten this far, all tests have passed
        return True

#TODO: make these Fields have validation and able to process statements
enamldef MyIntField(Field):
    """This class exists to make an IntField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = int(text)

enamldef MyFloatField(Field):
    """This class exists to make a FloatField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = float(text)

enamldef MyBoolField(Field):
    """This class exists to make a BoolField (which isn't something that is available anyway),
     that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = bool(text)

enamldef IndexedStack(GroupBox): indexedStack:
    attr iterable=Typed(ListProp)
    attr viewType #=Class(StackItem)  #do we really have to declare what type? I suppose this was so that we would be okay with creating an instance
    hug_height = 'strong'
    hug_width = 'strong'

    Container: controls:
        constraints=[hbox(addButton,removeButton,combo)]
        PushButton: addButton:
            text='+'
            constraints=[width==50,height==20]
            clicked::
                iterable.add()
                combo.maximum=len(iterable)-1
                combo.value=combo.maximum
        PushButton: removeButton:
            text='-'
            constraints=[width==50,height==20]
            clicked::
                i=combo.value
                if i>=0:
                    iterable.pop(i)
                    combo.maximum=len(iterable)-1
                    if i>1:
                        combo.value=i-1
                    else:
                        combo.value=0
        # RefreshableComboBox: combo:
            # items<<[str(i)+' '+n.description for i,n in enumerate(iterable)]
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum<<len(iterable)-1
            minimum=0
    Stack: stack:
        index<<combo.value
        RefreshableLooper:
            iterable<<indexedStack.iterable
            Include:
                objects=[viewType(item=loop_item)]

enamldef IndexedContainer(GroupBox): indexedStack:
    attr iterable=Typed(ListProp)
    attr viewType #=Class(StackItem)  #do we really have to declare what type? I suppose this was so that we would be okay with creating an instance
    hug_height = 'strong'
    hug_width = 'strong'

    Container: controls:
        constraints=[hbox(addButton,removeButton,combo)]
        PushButton: addButton:
            text='+'
            constraints=[width==50,height==20]
            clicked::
                iterable.add()
                combo.maximum=len(iterable)-1
                combo.value=combo.maximum
        PushButton: removeButton:
            text='-'
            constraints=[width==50,height==20]
            clicked::
                i=combo.value
                if i>=0:
                    iterable.pop(i)
                    combo.maximum=len(iterable)-1
                    if i>1:
                        combo.value=i-1
                    else:
                        combo.value=0
        # RefreshableComboBox: combo:
            # items<<[str(i)+' '+n.description for i,n in enumerate(iterable)]
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum<<len(iterable)-1
            minimum=0
     Stack: stack:
        index<<combo.value
        RefreshableLooper:
            iterable<<indexedStack.iterable
            Include:
                objects=[viewType(item=loop_item)]

def get_load_file_callback(experiment):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.load(dlg.path)
            except PauseError:
                pass
    return load_file_callback

def get_save_file_callback(experiment):
    def save_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.save(dlg.path)
            except PauseError:
                pass
    return save_file_callback

enamldef CsMenuBar(MenuBar): menuBar:
    attr experiment
    attr mainWindow
    
    Menu:
        title = '&File'
        Action:
            text = 'Load\tCtrl+L'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Choose file to load',
                    mode='open_file',
                    path=experiment.settings_path,
                    callback=get_load_file_callback(experiment),
                    ).open()
        Action:
            text = 'Save\tCtrl+S'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Save As?',
                    mode='save_file',
                    path=os.path.join(experiment.settings_path,'settings-{}.hdf5'.format(datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S'))),
                    callback=get_save_file_callback(experiment),
                    ).open()
        Action:
            text = 'Quit\tCtrl+Q'
            triggered::
                mainWindow.close()
    Menu:
        title = '&Experiment'
        Action:
            text = 'Reset and Run\tCtrl+R'
            triggered::experiment.resetAndGoThread()
        Action:
            text = 'Reset'
            triggered::experiment.resetThread()
        Action:
            text = 'Run'
            triggered::experiment.goThread()
        Menu:
            title = 'Pause...'
            Action:
                checkable = True
                text = 'After Measurement'
                checked := experiment.pauseAfterMeasurement
            Action:
                checkable = True
                text = 'After Iteration'
                checked := experiment.pauseAfterIteration
            Action:
                checkable = True
                text = 'After Error'
                checked := experiment.pauseAfterError
        Action:
            text = 'Continue\tCtrl+G'
            triggered::experiment.goThread()
        Action:
            text = 'End and Upload'
            triggered::experiment.endThread()
        Action:
            text = 'Halt\tCtrl+H'
            triggered::experiment.halt()
    Menu:
        title = '&Optimize'
        Action:
            text = 'Reset and Run'
            triggered::experiment.optimize_resetAndGoThread()

enamldef EvalProp(GroupBox):
    attr prop
    padding = 0
    flat = True
    title << prop.name
    constraints = [desc.width==func.width, func.width==val.width, hbox(desc,func,val), align('v_center',desc,func,val)]

    # can be made to show an error status by setting valid to false
    attr valid = True

    Field: desc:
        text := prop.description
        placeholder = 'description'

    Field: func:
        text := prop.function
        placeholder = prop.placeholder
        style_class << 'valid' if prop.valid else 'invalid'

    Label: val:
        text << prop.valueStr

enamldef MultilineProp(GroupBox):        
    attr prop
    flat=True
    title:=prop.name
    constraints=[vbox(desc,hbox(func,val)),align('top',func,val)]
    Field: desc:
        text:=prop.description
        placeholder='description'
    MultilineField: func:
        text:=prop.function
    Label: val:
        text << prop.valueStr

enamldef LabelBox(Container):
    attr checked #=False
    attr text #=''
    
    padding=0
    constraints=[hbox(label,box),align('v_center',label,box)]
    hug_height='strong'
    hug_width='strong'
    Label: label:
        text<<parent.text
    CheckBox: box:
        checked:=parent.checked

enamldef CheckField(Container):
    attr checked=False
    attr text=''
    attr placeholder=''
    
    constraints=[hbox(box,field),align('v_center',box,field)]
    CheckBox: box:
        checked:=parent.checked
    Field: field:
        text:=parent.text
        placeholder:=parent.placeholder

enamldef LabelField(Container):
    attr label=''
    attr text=''
    attr placeholder=''
    
    hug_height='strong'
    hug_width='strong'
    constraints=[vbox(l1,f1),l1.left==f1.left]
    Label: l1:
        text:=parent.label
    Field: f1:
        text:=parent.text
        placeholder:=parent.placeholder

#class RefreshableComboBox(ComboBox):
#    refresh = EnamlEvent

enamldef ExperimentPage(Page):
    attr experiment
    title='Experiment'

    Container:
        Form: form:
            Label:
                text="Status:"
            Label:
                text<<experiment.statusStr

            Label:
                text='Pause after iteration'
            CheckBox:
                checked:=experiment.pauseAfterIteration

            Label:
                text='Pause after measurement'
            CheckBox:
                checked:=experiment.pauseAfterMeasurement
            
            Label:
                text='Pause after error'
            CheckBox:
                checked:=experiment.pauseAfterError
            
            Label: text='Save Data?'
            CheckField:
                checked:=experiment.saveData
                text:=experiment.localDataPath
                placeholder='local data path'
            
            Label: text='Save Settings?'
            CheckBox:
                checked:=experiment.saveSettings
            
            Label: text='Save 2013 style files?'
            CheckBox:
                checked:=experiment.save2013styleFiles

            Label: text='Copy Data to Network?'
            CheckField:
                checked:=experiment.copyDataToNetwork
                text:=experiment.networkDataPath
                placeholder='network data path'

            Label: text='Experiment description suffix for filename'
            Field: text:=experiment.experimentDescriptionFilenameSuffix

            Label: text='Measurement Timeout [s]'
            FloatField: value:=experiment.measurementTimeout

            Label: text='Measurements per Iteration'
            IntField: value:=experiment.measurementsPerIteration
        
            Label: text='E-mail on error/completion?'
            CheckField:
                checked:=experiment.willSendEmail
                text:=experiment.emailAddresses
            
            Label: text='Progress'
            Label: text<<'{}%'.format(experiment.progressGUI)
            
            Label: text='Iteration'
            Label: text<<experiment.iterationStr
            
            Label: text='Measurement'
            Label: text<<experiment.measurementStr
            
            Label: text='Good Measurements'
            Label: text<<experiment.goodMeasurementsStr
            
            Label: text='Time started'
            Label: text<<experiment.timeStartedStr
            
            Label: text='Time after last measurement'
            Label: text<<experiment.currentTimeStr
            
            Label: text='Time elapsed'
            Label: text<<experiment.timeElapsedStr

            Label: text='Estimated total time'
            Label: text<<experiment.totalTimeStr

            Label: text='Estimated time remaining'
            Label: text<<experiment.timeRemainingStr

            Label: text='Estimated completion time'
            Label: text<<experiment.completionTimeStr
            
            Label: text='Notes'
            MultilineField:
                text:=experiment.notes

enamldef VariableEntry(GroupBox):
    attr indepVar

    constraints=[nameCont.width==0.5*descCont.width,descCont.width==funcCont.width,currentValueLabel.right==funcCont.right,vbox(hbox(nameCont,descCont,funcCont),valueListLabel,hbox(stepsLabel,currentValueLabel)),align('v_center',nameCont,descCont,funcCont),align('v_center',stepsLabel,currentValueLabel)]
    
    Field: nameCont:
        text:=indepVar.name
        placeholder='name'
    Field: descCont:
        text:=indepVar.description
        placeholder='description'
    Field: funcCont:
        text:=indepVar.function
        placeholder='function'
    Label: valueListLabel:
        text<<'values: '+indepVar.valueListStr
    Label: stepsLabel:
        text<<'step: '+str(indepVar.index)+' of '+str(indepVar.steps)
    Label: currentValueLabel:
        text<<'current value: '+indepVar.currentValueStr

enamldef IndependentVariablesGroupBox(GroupBox):
    attr independentVariables
    title='Independent Variables'
    
    GroupBox:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton0,removeButton0)]
        SpinBox: spin0:
            minimum=0
            maximum << independentVariables.length
        PushButton: addButton0:
            text='+'
            clicked::
                independentVariables.add_at(spin0.value)
        PushButton: removeButton0:
            text='-'
            clicked::
                independentVariables.pop(spin0.value)

    RefreshableLooper:
        iterable<<independentVariables
        VariableEntry:
            indepVar << loop_item

enamldef VariablesPage(Page): main:
    attr experiment
    title = 'Variables'
    Container:
        Container:
            hug_height='strong'
            hug_width='strong'

            Container: settings:
                padding=0
                hug_height='strong'
                hug_width='strong'

                PushButton: updateButton:
                    text='Update variables throughout experiment'
                    clicked::
                        experiment.evaluateAll()
                IndependentVariablesGroupBox: independent:
                    independentVariables<<experiment.independentVariables

                GroupBox: dependent:
                    title='Dependent Variables'
                    constraints=[vbox(lb1,field,variablesNotToSave)]
                    Label: lb1:
                        text='Define dependent variables using python code below.'
                    MultilineField: field:
                        constraints=[height==600]
                        text:=experiment.dependentVariablesStr
                    GroupBox: variablesNotToSave:
                        hug_height='strong'
                        title='Variables Not To Save to HDF5 (comma separated)'
                        Field:
                            text:=experiment.variablesNotToSave
                            placeholder='scipy,numpy,x'

enamldef Reports(Container):
    attr experiment
    GroupBox: report:
        title = 'Variable Report'
        hug_height = 'strong'
        hug_width = 'strong'
        constraints = [hbox(f1,lb2),align('top',f1,lb2)]
        MultilineField: f1:
            constraints = [height==600, width==600]
            text := experiment.variableReport.function
            style_class << 'valid' if experiment.variableReport.valid else 'invalid'
        Label: lb2:
            text << experiment.variableReport.valueStr

enamldef LabViewPage(Page):
    attr LabView
    title = 'LabView'
    
    Container:
        Container:
            hug_height='strong'
            Container:
                constraints=[hbox(b1,b3,b4),b1.width==100,b3.width==100,b4.width==100]
                PushButton: b1:
                    text='open connection'
                    clicked::
                        LabView.openThread()
                PushButton: b3:
                    text='update settings'
                    clicked::
                        LabView.update()
                PushButton: b4:
                    text='close connection'
                    clicked::
                        LabView.close()

            Form:
                Label:
                    text='enable communication with LabView system?'
                CheckBox:
                    checked:=LabView.enabled
                Label:
                    text='IP address of LabView system'
                Field:
                    text:=LabView.IP
                Label:
                    text='communications port'
                IntField:
                    value:=LabView.port
                Label:
                    text='cycle experiment continuously even when not taking data?'
                CheckBox:
                    checked:=LabView.cycleContinuously
            EvalProp:
                prop<<LabView.timeout
            Form:
                Label:
                    text='connected'
                CheckBox:
                    checked:=LabView.connected
                    enabled=False
                Label: text='LabView error'
                Label: text<<str(LabView.error)
            
            GroupBox:
                title='TCP output message'
                constraints = [vbox(scroller1),(height==500)|'strong']
                hug_width='ignore'
                ScrollArea:scroller1:
                    Container:
                        hug_height='ignore'
                        hug_width='ignore'
                        Label:
                            hug_height='ignore'
                            hug_width='ignore'
                            text<<LabView.msg

            GroupBox:
                title='LabView log'
                constraints = [vbox(scroller2),(height==500)|'strong']
                hug_width='ignore'
                ScrollArea: scroller2:
                    Container:
                        hug_height='ignore'
                        hug_width='ignore'
                        Label:
                            hug_height='ignore'
                            hug_width='ignore'
                            text<<LabView.log

enamldef DOchannel(Container):
    attr channel
    attr index
    hug_height='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel.description
        placeholder='description'
    Field: activeF:
        text:=channel.active.function
        placeholder='active?'
    Label: activeL:
        text<<str(channel.active.value)

enamldef HSDIOScriptTrigger(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
        EvalProp:
            prop<<item.id
        EvalProp:
            prop<<item.source
        EvalProp:
            prop<<item.type
        EvalProp:
            prop<<item.edge
        EvalProp:
            prop<<item.level

enamldef StartTrigger(GroupBox):
    attr trigger
    title='Start Trigger'
    
    EvalProp:
        prop<<trigger.waitForStartTrigger
    EvalProp:
        prop<<trigger.source
    EvalProp:
        prop<<trigger.edge

class RefreshableMPLCanvas(MPLCanvas):
    """ An MPLCanvas that can be refreshed on command by toggling refresh.
    Requires adding a function to MPLCanvas in
    C:\Users\Saffmanlab\AppData\Local\Enthought\Canopy\User\Lib\site-packages\enaml\qt\qt_mpl_canvas.py:
        def on_action_set_refresh(self, content):
            self.refresh_mpl_widget()
    """
    
    #: Toggle this to refresh the canvas
    refresh = d_(Bool())

class RemoveEventContainer(Container):
    remove=d_(Bool())

enamldef NumpyDOchannel(Container):
    attr channel
    attr index
    attr digitalout #the DAQmxDO or HSDIO
    attr experiment

    hug_height='strong'
    hug_width='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel['description']
        placeholder='description'
    Field: activeF:
        text:=channel['function']
        placeholder='active?'
        validator<<MyBoolValidator(experiment)
        text::
            channel['value']=experiment.eval_bool(text)
            activeL.text=str(channel['value']) #must be updated manually because the channel['value'] identity does not change
            digitalout.evaluate()
    Label: activeL:
        text<<str(channel['value'])

enamldef NumpyDOchannels(GroupBox):
    attr channels
    title='channels (#, description, active?)'
    hug_height='strong'
    hug_width='strong'
    #constraints=[controls.left==dynoCont.left]
    Container: controls:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton,removeButton)]
        SpinBox: spin0:
            minimum=0
            maximum<<len(channels.array)
        PushButton: addButton:
            text='+'
            clicked::
                channels.add(spin0.value)
        PushButton: removeButton:
            text='-'
            clicked::
                channels.remove(spin0.value)
    Container: dynoCont:
        Include: dyno:
            objects<<[NumpyDOchannel(channel=x,index=i,digitalout=channels.digitalout,experiment=channels.experiment) for i,x in enumerate(channels.array)]

enamldef NumpyState(Form):
    attr state
    attr experiment
    attr waveform
    attr value_str
    attr valid

    padding=0

    Field:
        constraints = [width == 100,height==20]
        style_class << 'valid' if valid else 'invalid'
        text:=state['function']
        text::
            value, parent.valid = experiment.eval_general(text)
            if value is None:
                state['value'] = 5
                parent.value_str = ''
            elif (value == 0) or (value ==1):
                state['value'] = value
                parent.value_str = str(state['value']) #must be updated manually because state['value'] identity does not change
            else:
                logger.warning('Invalid state in waveform {}.  States must evaluate to None, 0 or 1.\n{} = {}'.format(waveform.name,text,value))
                state['value'] = 5
                parent.value_str = ''
                parent.valid = False
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width==50, height==20]
        text << value_str

enamldef ChannelCombo(ComboBox):
    attr wfm
    attr channels
    attr channelList
    attr position
    
    items<<[str(i)+' '+x for i,x in enumerate(channels.array['description'])]
    index<<int(channelList[position])
    index::
        channelList[position]=numpy.uint8(index)
        wfm.updateFigure()

enamldef TransitionsLabel(Container):
    padding=0
    Label:
        constraints = [height == 20]
        text='description'
    Label:
        constraints = [height == 20]
        text='time'

enamldef DescriptionLabel(Label):
    constraints = [height == 20]
    text='description'
    
enamldef TimeLabel(Label):
    constraints = [height == 20]
    text='time'

enamldef TransitionDescription(Field):
    attr transition
    constraints = [height==20]
    placeholder = 'description'
    text:=transition['description']

enamldef TransitionTime(Form):
    attr experiment
    attr waveform
    attr transition
    attr value_str
    attr valid
    
    padding=0
    
    Field:
        constraints = [width == 100, height==20]
        placeholder = 'time'
        text := transition['function']
        style_class << 'valid' if valid else 'invalid'
        text::
            transition['value'], parent.valid = experiment.eval_float(text)
            value_str = '{:.6f}'.format(transition['value']) #must be updated manually because transition['value'] identity does not change
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width==50, height==20]
        text << value_str

enamldef NumpyWaveform(Container):
    attr waveform
    
    hug_height='strong'
    hug_width='ignore'
    constraints=[vbox(plotcontrols,details),align('left',plotcontrols,details)]
    
    Container: plotcontrols:
        hug_width='strong'
        hug_height='strong'
        constraints=[hbox(lmin,plotmin,lmax,plotmax)]
        padding=0
        Label: lmin:
            text='plot min'
        Field: plotmin:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmin=-1
                else:
                    waveform.plotmin=float(text)
                waveform.updateFigure()
        Label: lmax:
            text='plot max'
        Field: plotmax:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmax=-1
                else:
                    waveform.plotmax=float(text)
                waveform.updateFigure()
    
    Container: details:
        constraints=[vbox(hbox(nameField,timeControls,channelControls),transitions)]
        hug_height='strong'
        hug_width='strong'

        Field: nameField:
            constraints = [width == 150, height == 20]
            text:=waveform.name

        GroupBox: timeControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l0,spin0,addButton0,removeButton0)]
            Label: l0:
                text='times'
            SpinBox: spin0:
                minimum=0
                maximum<<len(waveform.transitions.array)
            PushButton: addButton0:
                text='+'
                clicked::
                    waveform.addTransition(spin0.value)
            PushButton: removeButton0:
                text='-'
                clicked::
                    waveform.removeTransition(spin0.value)

        GroupBox: channelControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l1,spin1,addButton1,removeButton1)]
            Label: l1:
                text='channels'
            SpinBox: spin1:
                minimum=0
                maximum<<len(waveform.channelList)
            PushButton: addButton1:
                text='+'
                clicked::
                    waveform.addChannel(spin1.value)
            PushButton: removeButton1:
                text='-'
                clicked::
                    waveform.removeChannel(spin1.value)
        GroupBox: transitions:
            hug_height='strong'
            hug_width='strong'
            title='waveform transition and sequence (valid states: blank(continue), 0(off), 1(on))'
            constraints<<[grid(*[statesDyno.objects[i:(i+len(waveform.transitions.array)+1)] for i in range(0, len(statesDyno.objects), len(waveform.transitions.array)+1)])] if len(statesDyno.objects)>0 else []
            Include: statesDyno:
                objects << ([DescriptionLabel()]
                    +[TransitionDescription(transition=t) for t in waveform.transitions.array]
                    +[TimeLabel()]
                    +[TransitionTime(transition=t,experiment=waveform.experiment,waveform=waveform,value_str=value_str,valid=valid) for t,value_str,valid in zip(waveform.transitions.array,waveform.transitions.value_str,waveform.transitions.valid)]
                    +(list(itertools.chain(*map(list,zip(*([[ChannelCombo(wfm=waveform,channels=waveform.digitalout.channels,channelList=waveform.channelList,position=i) for i in xrange(len(waveform.channelList))]]
                    +[[NumpyState(state=s,experiment=waveform.experiment,waveform=waveform,value_str=value_str,valid=valid) for s,value_str,valid in zip(waveform.sequence.array.flat,waveform.sequence.value_str.flat,waveform.sequence.valid.flat)][i:i+len(waveform.channelList)] for i in range(0,waveform.sequence.array.size,len(waveform.channelList))]))))) if (len(waveform.channelList)>0) else [])
                    )

def get_load_waveform_callback(HSDIO):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                HSDIO.import_waveform(dlg.path)
            except PauseError:
                pass
    return load_file_callback

enamldef Waveforms(Container):
    attr HSDIO

    Container:
        hug_height='strong'
        hug_width='strong'
        constraints=[vbox(buttons,c1),align('left',buttons,c1)]
        Container: buttons:
            constraints=[hbox(combo,importWaveform,addWaveform,removeWaveform,copyWaveform)]
            hug_height='strong'
            hug_width='strong'
            ComboBox: combo:
                constraints=[(width==500)|'strong']
                items << list(HSDIO.waveforms.names)
                index = (0 if (HSDIO.waveforms.length>0) else -1) # pick first profile on load
            PushButton: importWaveform:
                enabled = False
                #add a waveform from a file
                text='import'
                clicked::
                    dlg = FileDialog(
                        parent=importWaveform,
                        title='Choose file to load waveform from',
                        mode='open_file',
                        path=HSDIO.import_path,
                        callback=get_load_waveform_callback(HSDIO),
                        ).open()
                    combo.index=len(HSDIO.waveforms)-1
            PushButton: addWaveform:
                constraints=[(width==50)|'strong']
                text = 'add'
                clicked::
                    HSDIO.waveforms.add()
                    combo.index=len(HSDIO.waveforms)-1
            PushButton: removeWaveform:
                constraints=[(width==50)|'strong']
                text = 'remove'
                clicked::
                    i=combo.index
                    if i>=0:
                        if i>1:
                            combo.index=i-1
                        else:
                            combo.index=0
                        HSDIO.waveforms.pop(i)
            PushButton: copyWaveform:
                constraints=[(width==50)|'strong']
                text = 'copy'
                clicked::
                    HSDIO.waveforms.copy(combo.index)
                    combo.index=len(HSDIO.waveforms)-1
        Container: c1:
            padding=0
            Conditional:
                condition << ((HSDIO.waveforms.length>0) and (combo.index >= 0))
                Container:
                    padding=0
                    constraints=[vbox(canvas,stack),align('left',canvas,stack)]
                    MPLCanvas: canvas:
                        constraints=[(height==1000)|'strong',(width==1500)|'strong']
                        figure << HSDIO.waveforms.listProperty[combo.index].figure
                    Container: stack:
                        padding=0
                        # There were too many problems with getting a stack to update properly, so we are using the slower to switch but
                        # quicker to instantiate single element
                        NumpyWaveform:
                            waveform << HSDIO.waveforms.listProperty[combo.index]

enamldef HSDIO_DigitalOutPage(Page):
    attr HSDIO
    title = 'HSDIO Pulses'

    Container:
        Container:
                constraints=[hbox(vbox(p1,p9,p2,p4,p5,p6,p7,p8),p3),align('left',p1,p9,p2,p4,p5,p6,p7),align('top',p1,p3)]
                hug_height='strong'
                hug_width='strong'
                EvalProp: p1:
                    prop<<HSDIO.enable
                StartTrigger: p9:
                    trigger<<HSDIO.startTrigger
                IndexedStack: p2:
                    title='Script Triggers'
                    iterable<<HSDIO.triggers
                    viewType=HSDIOScriptTrigger
                MultilineProp: p3:
                    prop<<HSDIO.script
                EvalProp: p4:
                    prop<<HSDIO.resourceName
                EvalProp: p5:
                    prop<<HSDIO.clockRate
                EvalProp: p6:
                    prop<<HSDIO.units
                EvalProp: p7:
                    prop<<HSDIO.hardwareAlignmentQuantum
                NumpyDOchannels: p8:
                    channels<<HSDIO.channels

enamldef DAQmxDigitalOutPage(Page):
    title = 'DAQmx DO'    
    attr DAQmx
    
    Container:
        Container:
                constraints=[vbox(canvas,p6,hbox(vbox(p0,p1,p2,p3,p4),p5)),align('top',p0,p5)]
                hug_height='strong'
                hug_width='strong'
                EvalProp: p0:
                    prop<<DAQmx.enable
                EvalProp: p1:
                    prop<<DAQmx.resourceName
                EvalProp: p2:
                    prop<<DAQmx.clockRate
                EvalProp: p3:
                    prop<<DAQmx.units
                StartTrigger: p4:
                    trigger<<DAQmx.startTrigger
                NumpyDOchannels: p5:
                    channels<<DAQmx.channels
                NumpyWaveform: p6:
                    waveform<<DAQmx.waveform
                MPLCanvas: canvas:
                    constraints=[(height==500)|'strong',(width==1500)|'strong']
                    figure << DAQmx.waveform.figure

enamldef DDS_profile(Container):
    attr profile
    
    hug_height='strong'
    hug_width='strong'
    padding=0

    Container:
        padding=0
        hug_height='strong'
        hug_width='strong'
        constraints=[vbox(description,hbox(container1,container2))]
        Form: description:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=profile.description
        Container: container1:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.frequency
            EvalProp:
                prop<<profile.amplitude
            EvalProp:
                prop<<profile.phase
            EvalProp:
                prop<<profile.RAMMode
            EvalProp:
                prop<<profile.ZeroCrossing
            EvalProp:
                prop<<profile.NoDwellHigh
            EvalProp:
                prop<<profile.FunctionOrStatic
        Container: container2:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.RAMFunction
            EvalProp:
                prop<<profile.RAMInitialValue
            EvalProp:
                prop<<profile.RAMStepValue
            EvalProp:
                prop<<profile.RAMTimeStep
            EvalProp:
                prop<<profile.RAMNumSteps
            IndexedStack:
                title='RAMStaticArray'
                iterable<<profile.RAMStaticArray
                viewType=ItemProp

enamldef ItemProp(StackItem):
    attr item
    
    Container:
        padding=0
        EvalProp:
            prop<<item

enamldef DDS_channel(GroupBox):
    attr channel
    attr index
    
    title='channel '+str(index)
    constraints=[hbox(vbox(parameters,RAM),profiles)]

    GroupBox: parameters:
        title='channel parameters'
        flat=True
        constraints=[vbox(description,power,refClockRate,fullScaleOutputPower)]
        Form: description:
            Label:
                text='description'
            Field:
                text:=channel.description
        EvalProp: power:
            prop<<channel.power
        EvalProp: refClockRate:
            prop<<channel.refClockRate
        EvalProp: fullScaleOutputPower:
            prop<<channel.fullScaleOutputPower
    
    GroupBox: RAM:
        title='RAM defaults'
        flat=True
        EvalProp:
            prop<<channel.RAMenable
        EvalProp:
            prop<<channel.RAMDestType
        EvalProp:
            prop<<channel.RAMDefaultFrequency
        EvalProp:
            prop<<channel.RAMDefaultAmplitude
        EvalProp:
            prop<<channel.RAMDefaultPhase

    GroupBox: profiles:
        title='profiles'
        hug_height='strong'
        hug_width='strong'
        ComboBox: combo:
            items << list(channel.profileDescriptionList)
            index = (0 if (channel.profiles.length>0) else -1) # pick first profile on load
#        Stack: p1:
#            index<<combo.index
#            RefreshableLooper:
#                iterable<<channel.profiles
#                StackItem:
#                    DDS_profile:
#                        profile<<loop_item
        Conditional:
            condition << ((channel.profiles.length>0) and (combo.index >= 0))
            DDS_profile:
                profile << channel.profiles.listProperty[combo.index]

enamldef DDS_box(Form):
    attr box

    Label:
        text='enable'
    CheckBox:
        checked:=box.enable

    Label:
        text='Description'
    Field:
        text:=box.description

    PushButton:
        text='select USB device reference'
        clicked::
            box.deviceReference=combo.selected_item.strip()
    ComboBox: combo:
        items<<list(box.DDS.deviceList)

    Label:
        text='NI USB-8451 device reference'
    Field:
        pass
        text:=box.deviceReference

    Label:
        text='DIO port'
    IntField:
        #maximum = sys.maxint  # this crashes on Windows, but not on OS X
        maximum = 999999
        minimum = 0
        value:=box.DIOport
    Label:
        text='serialClockRate'
    IntField:
        value := box.serialClockRate

    GroupBox:
        hug_height='strong'
        hug_width='strong'
        title='channels'
        RefreshableLooper:
            iterable<<box.channels
            DDS_channel:
                index<<loop_index
                channel<<loop_item

enamldef DDS_Page(Container): page:
    attr DDS

    Container:
        hug_width='strong'
        hug_height='strong'
        constraints=[vbox(hbox(enable,isInit,getDevicesButton,initButton,loadButton),stackGroup),align('v_center',getDevicesButton,initButton,loadButton,enable,isInit),enable.width==500,getDevicesButton.width==200,initButton.width==200,loadButton.width==200]
        EvalProp: enable:
                    prop<<DDS.enable
        PushButton: getDevicesButton:
            text='Get DDS Device List'
            clicked::DDS.getDDSDeviceListThread()
        PushButton: initButton:
            text='Initialize and Load'
            clicked::DDS.initializeDDSThread()
        PushButton: loadButton:
            text='Load'
            clicked::DDS.loadDDSThread()

        #LabelBox: enable:
        #    text='enable'
        #    checked:=DDS.enable.value

        LabelBox: isInit:
            text='initialized?'
            checked<<DDS.isInitialized
            enabled=False #keep it greyed out.

        GroupBox: stackGroup:
            pass
            title='DDS boxes'
            constraints=[vbox(hbox(combo,addButton,removeButton),stack),stack.width==contents_width]
            ComboBox: combo:
                items<<list(DDS.boxDescriptionList)
                index = (0 if (DDS.boxes.length>0) else -1) # pick first profile on load
            PushButton: addButton:
                text='+'
                constraints=[width==50,height==20]
                clicked::
                    DDS.boxes.add()
                    DDS.updateBoxDescriptionList()
                    combo.index=len(DDS.boxes)-2 #point to new box
            PushButton: removeButton:
                text='-'
                constraints=[width==50,height==20]
                clicked::
                    i=combo.index
                    if i>=0:
                        DDS.boxes.pop(i)
                        DDS.updateBoxDescriptionList()
                        combo.index=i-1
#            Stack: stack:
#                index<<combo.index
#                RefreshableLooper:
#                    iterable<<DDS.boxes
#                    StackItem:
#                        DDS_box:
#                            box<<loop_item
            Container: stack:
                padding = 0
                Conditional:
                    condition << ((DDS.boxes.length>0) and (combo.index >= 0))
                    DDS_box:
                        box<<DDS.boxes.listProperty[combo.index]

enamldef RF_gen(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            Label:
                text='description'
            Field:
                text:=item.description
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power

enamldef HP83623A(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            
            Label:
                text='description'
            Field:
                text:=item.description
            
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power
        EvalProp:
            prop<<item.RFoutput
        EvalProp:
            prop<<item.externalTrigger

enamldef RFGenPage(Page):
    attr LabView
    title = 'RF Generators'
    Container:
        EvalProp:
            prop<<LabView.RF_generators.enable
        IndexedStack: i1:
            title='HP83623A'
            iterable=LabView.RF_generators.HP83623A_list
            viewType=HP83623A
        IndexedStack: i2:
            title='HP8662A'
            iterable=LabView.RF_generators.HP8662A_list
            viewType=RF_gen
        IndexedStack: i3:
            title='HP83712B'
            iterable=LabView.RF_generators.HP83712B_list
            viewType=RF_gen

enamldef CameraPage(Page):
    attr camera
    title = 'Camera'
    Container:
        Container:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<camera.enable
            EvalProp:
                prop<<camera.saveAsPNG
            EvalProp:
                prop<<camera.saveAsASCII
            EvalProp:
                prop<<camera.forceImagesToU16
            EvalProp:
                prop<<camera.EMGain
            EvalProp:
                prop<<camera.analogGain
            EvalProp:
                prop<<camera.exposureTime
            EvalProp:
                prop<<camera.scanSpeed
            EvalProp:
                prop<<camera.lowLightSensitivity
            EvalProp:
                prop<<camera.externalTriggerMode
            EvalProp:
                prop<<camera.triggerPolarity
            EvalProp:
                prop<<camera.externalTriggerSource
            EvalProp:
                prop<<camera.cooling
            EvalProp:
                prop<<camera.fan
            EvalProp:
                prop<<camera.scanMode
            EvalProp:
                prop<<camera.photoelectronScaling
            EvalProp:
                prop<<camera.subArrayLeft
            EvalProp:
                prop<<camera.subArrayTop
            EvalProp:
                prop<<camera.subArrayWidth
            EvalProp:
                prop<<camera.subArrayHeight
            EvalProp:
                prop<<camera.superPixelBinning
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionLeft
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionTop
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionRight
            EvalProp:
                prop<<camera.frameGrabberAcquisitionRegionBottom
            EvalProp:
                prop<<camera.numImageBuffers
            EvalProp:
                prop<<camera.shotsPerMeasurement

enamldef CounterPage(Page):
    title = 'Counter'

enamldef FiltersPage(Page):
    title = 'Filters'

enamldef AOequation(StackItem):
    attr item
    Container:
        hug_height='strong'
        hug_width='strong'
        GroupBox:
            flat=True
            title='description'
            Field:
                constraints=[width==500]
                text:=item.description
                placeholder='description'
        GroupBox:
            flat=True
            title='function'
            Field:
                constraints=[width==500]
                text:=item.function
                placeholder='function that evaluates to a 1D array, where t will be replaced with AO.timesteps'

enamldef AnalogOutputPage(Page):
    attr AO
    title = 'Analog output'
    Container:
        hug_height='strong'
        #hug_width='strong'
        constraints=[vbox(e1,canvas,equations,c1),align('left',e1,canvas,equations,c1)]
        #constraints=[vbox(e1,equations,c1),align('left',e1,equations,c1)]
        LabelBox: e1:
            text='enable'
            checked:=AO.enable
        #the following 4 lines are for chaco plotting
        #EnableCanvas: canvas:
        #    #TODO: make this expand and shrink nicely while filling the width
        #    constraints=[height==500,width==1500]
        #    component<<AO.plot
        #the following lines are for MPL plotting
        MPLCanvas: canvas:
            constraints=[(height==500)|'strong']
            hug_width='ignore'
            figure << AO.figure
        IndexedStack: equations:
            title='equations'
            iterable<<AO.equations
            viewType=AOequation
        Container: c1:
            hug_height='strong'
            hug_width='strong'
            constraints=[grid([e2,e3,e4],[e5,e6,e7],[e8,e9,e10],[e11,e12])]
            EvalProp: e2:
                prop<<AO.physicalChannels
            EvalProp: e3:
                prop<<AO.minimum
            EvalProp: e4:
                prop<<AO.maximum
            EvalProp: e5:
                prop<<AO.clockRate
            EvalProp: e6:
                prop<<AO.units
            EvalProp: e7:
                prop<<AO.totalAOTime
            EvalProp: e8:
                prop<<AO.waitForStartTrigger
            EvalProp: e9:
                prop<<AO.triggerSource
            EvalProp: e10:
                prop<<AO.triggerEdge
            EvalProp: e11:
                prop<<AO.exportStartTrigger
            EvalProp: e12:
                prop<<AO.exportStartTriggerDestination

enamldef AnalogInput(Container):
    attr AI

    hug_height = 'strong'
    hug_width = 'strong'

enamldef Arroyo(Container):
    attr Arroyo

    hug_height = 'strong'
    hug_width = 'strong'

enamldef PiezoChannel(Container):
    attr channel
    
    hug_height = 'strong'
    hug_width = 'strong'
    constraints=[hbox(description, setServo,setPosition,label)]
    Field: description:
        placeholder='description'
        text:=channel.description
    EvalProp: setServo:
        prop<<channel.setServo
    EvalProp: setPosition:
        prop<<channel.setPosition
    GroupBox: label:
        flat=True
        title='read from piezo'
        Label:
            text<<'axis:{}\tservo:{}\tposition:'.format(channel.readAxis,channel.readServo,channel.readPosition)

enamldef PiezoController(StackItem):
    attr item
    
    Container:
        hug_height = 'strong'
        hug_width = 'strong'
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
            Label:
                text='enable'
            CheckBox:
                checked::item.enable
            Label:
                text='serial number set:'
            Field:
                placeholder='serial number'
                text:=item.serialNumber
            Label:
                text='id:'
            Label:
                text:=item.identificationRead
            Label:
                text='serial number read:'
            Label:
                text:=item.serialNumberRead
        RefreshableLooper:
            iterable<<item.channels
            PiezoChannel:
                channel<<loop_item

enamldef PI_PiezoPage(Page):
    attr piezo
    title = 'PI Piezo'
    Container:
        LabelBox:
            text='enable'
            checked:=piezo.enable
        IndexedStack:
            title='Piezo Controllers'
            iterable<<piezo.controllers
            viewType=PiezoController

enamldef AnalysisImage(Container):
    attr analysis
    
    padding=0
    constraints=[(height==550)|'strong',(width==550)|'strong']
    MPLCanvas:
        constraints=[(height==550)|'strong',(width==550)|'strong']
        figure<<analysis.figure

enamldef MultiImagePage(Page): page:
    title='Images'
    attr experiment
    attr analysis0
    attr analysis1
    attr analysis2
    attr analysis3

    Container:
        constraints=[vbox(l0,hbox(a0,a1,a2)),align('top',a0,a1,a2)]
        
        Label: l0:
            text<<analysis3.text

        Container: a0:
            hug_height = 'strong'
            hug_width = 'strong'
            AnalysisImage:
                analysis<<analysis0
            Form:
                Label:
                    text = 'Show ROIs?'
                CheckBox:
                    checked := analysis0.showROIs
                Label:
                    text = 'shot'
                SpinBox:
                    minimum=0
                    value := analysis0.shot

        Container: a1:
            hug_height='strong'
            hug_width='strong'
            AnalysisImage:
                analysis<<analysis1
            Form:
                Label:
                   text='Show ROIs?'
                CheckBox:
                    checked:=analysis1.showROIs
            GroupBox:
                hug_height='strong'
                hug_width='strong'
                Looper:
                    iterable << analysis1.ivarNames
                    Form:
                        Label:
                            text<<loop_item
                        ComboBox:
                            items<<[str(i) for i in analysis1.ivarValueLists[loop_index]]
                            index::
                                analysis1.setIteration(loop_index, index) #send which ivar (loop_index) to update to index
                Form:
                    Label:
                        text='Measurement'
                    SpinBox:
                        minimum=0
                        maximum=9999999 #a big number
                        value:=analysis1.measurement
                Form:
                    Label:
                        text='Shot'
                    SpinBox:
                        minimum=0
                        maximum=9999999 #a big number
                        value:=analysis1.shot
        Container: a2:
            hug_height = 'strong'
            hug_width = 'strong'
            AnalysisImage:
                analysis<<analysis2
            Form:
                Label:
                   text='Show ROIs?'
                CheckBox:
                    checked:=analysis2.showROIs
                Label:
                    text = 'shot'
                SpinBox:
                    minimum=0
                    value := analysis2.shot

enamldef SquareROI(Container):
    attr item
    attr num
    hug_height='strong'
    hug_width='strong'
    constraints=[hbox(l0,f0,f1,f2,f3,f4)]
    Label: l0:
        constraints = [(width==50)|'strong']
        text=str(num)
    MyIntField: f0:
        constraints = [(width==100)|'strong']
        placeholder='left'
        value:=item['left']
    MyIntField: f1:
        constraints = [(width==100)|'strong']
        placeholder='top'
        value:=item['top']
    MyIntField: f2:
        constraints = [(width==100)|'strong']
        placeholder='right'
        value:=item['right']
    MyIntField: f3:
        constraints = [(width==100)|'strong']
        placeholder='bottom'
        value:=item['bottom']
    MyFloatField: f4:
        constraints = [(width==100)|'strong']
        placeholder='threshold'
        value:=item['threshold']

enamldef SquareROIContainer(Container):
    attr experiment
    attr analysis
    
    hug_height='ignore'
    hug_width='ignore'
    constraints=[hbox(dynoCont,canvas),align('top',dynoCont,canvas)]
    Container: dynoCont:
        Container:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l0,l1,l2,l3,l4,l5)]
            Label: l0:
                constraints = [(width==50)|'strong']
                text = 'ROI#'
            Label: l1:
                constraints = [(width==100)|'strong']
                text = 'left'
            Label: l2:
                constraints = [(width==100)|'strong']
                text = 'top'
            Label: l3:
                constraints = [(width==100)|'strong']
                text = 'right'
            Label: l4:
                constraints = [(width==100)|'strong']
                text = 'bottom'
            Label: l5:
                constraints = [(width==100)|'strong']
                text = 'threshold'
        Include: dyno:
            objects<<[SquareROI(item=x,num=i) for i,x in enumerate(analysis.ROIs)]
    MPLCanvas: canvas:
        constraints=[(height==1000)|'strong',(width==1000)|'strong']
        hug_width='ignore'
        figure<<analysis.figure

enamldef GaussianROI(Container):
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    HGroup:
        Label:
            text = 'enable'
        CheckBox:
            checked := analysis.enable
        Label:
            text = 'shot'
        SpinBox:
            value := analysis.shot
        Label:
            text = 'initial guess'
        Label:
            text = 'top'
        FloatField:
            value := analysis.top
        Label:
            text = 'left'
        FloatField:
            value := analysis.left
        Label:
            text = 'bottom'
        FloatField:
            value := analysis.bottom
        Label:
            text = 'right'
        FloatField:
            value := analysis.right
    MPLCanvas:
        constraints=[(height==1000)|'strong',(width==1700)|'strong']
        figure<<analysis.figure

enamldef LoadingFilters(GroupBox):
    attr filters
    title = 'Region of Interest Sum (Loading) Filters'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := filters.enable

        Label:
            text = 'A boolean expression that evaluates the filter.\nUse t[shot,region] for the summation over any shot and region.\nFor example to require that sites 15 and 17 load: t[0,17]>20000 and t[0,15]>21000'
        Field:
            text := filters.filter_expression
            style_class << 'valid' if filters.valid else 'invalid'

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

        Label:
            text = 'Status'
        Label:
            text := filters.text

enamldef FirstMeasurementsFilter(GroupBox):
    attr filters
    title = 'Drop First N Measurements Filter'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := filters.enable

        Label:
            text = 'How many measurements should we drop at the beginning of each iteration?'
        SpinBox:
            minimum = 0
            value := filters.N

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

enamldef Histogram(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := analysis.enable
        Label:
            text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
        Field:
            text := analysis.list_of_what_to_plot
    MPLCanvas:
        constraints=[(height==900)|'strong',(width==1700)|'strong']
        #hug_width='ignore'
        figure<<analysis.figure

enamldef HistogramGrid(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := analysis.enable
        Label:
            text = 'shot'
        SpinBox:
            value := analysis.shot
    MPLCanvas:
        constraints=[(height==1700)|'strong',(width==1700)|'strong']
        figure<<analysis.figure

enamldef MeasurementsGraph(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := analysis.enable
        Label:
            text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
        Field:
            text := analysis.list_of_what_to_plot
    PushButton:
        text = 'clear'
        clicked :: analysis.clear()
    MPLCanvas:
        constraints = [(height==900)|'strong',(width==1700)|'strong']
        figure << analysis.figure

enamldef IterationsGraph(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
        Field:
            text := analysis.list_of_what_to_plot
    Container:
        constraints = [hbox(l5,cb5,l0,cb0,l1,cb1,l2,cb2,l3,f3,l4,f4)]
        Label: l5:
            text = 'enable'
        CheckBox: cb5:
            checked := analysis.enable
        Label: l0:
            text = 'draw connecting lines'
        CheckBox: cb0:
            checked := analysis.draw_connecting_lines
        Label: l1:
            text = 'draw error bars (1 sigma std dev of mean)'
        CheckBox: cb1:
            checked := analysis.draw_error_bars
        Label: l2:
            text = 'only add data that has passed loading filter'
        CheckBox: cb2:
            checked := analysis.add_only_filtered_data
        Label: l3:
            text = 'plot ymin'
        Field: f3:
            placeholder='blank for autolimit'
            text := analysis.ymin
        Label: l4:
            text = 'plot ymax'
        Field: f4:
            placeholder='blank for autolimit'
            text := analysis.ymax
    MPLCanvas:
        constraints=[(height==900)|'strong',(width==1700)|'strong']
        figure<<analysis.figure

enamldef RetentionGraph(Container):
    attr experiment
    attr analysis

    hug_height='ignore'
    hug_width='ignore'
    Form:
        Label:
            text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
        Field:
            text := analysis.list_of_what_to_plot
    Container:
        constraints = [hbox(l5,cb5,l0,cb0,l1,cb1,l2,cb2,l3,f3,l4,f4)]
        Label: l5:
            text = 'enable'
        CheckBox: cb5:
            checked := analysis.enable
        Label: l0:
            text = 'draw connecting lines'
        CheckBox: cb0:
            checked := analysis.draw_connecting_lines
        Label: l1:
            text = 'draw error bars (1 sigma binomial std dev of mean using normal approximation)'
        CheckBox: cb1:
            checked := analysis.draw_error_bars
        Label: l2:
            text = 'only add data that has passed loading filter'
        CheckBox: cb2:
            checked := analysis.add_only_filtered_data
        Label: l3:
            text = 'plot ymin'
        Field: f3:
            placeholder='blank for autolimit'
            text := analysis.ymin
        Label: l4:
            text = 'plot ymax'
        Field: f4:
            placeholder='blank for autolimit'
            text := analysis.ymax
    MPLCanvas:
        constraints=[(height==900)|'strong',(width==1700)|'strong']
        figure<<analysis.figure

enamldef TTL_filters(GroupBox):
    attr instrument
    attr filters
    title = 'TTL (Laser Lock Monitor) Filters'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := instrument.enable

        Label:
            text = 'lines'
        Field:
            text := instrument.lines

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

        Label:
            text = 'Status'
        Label:
            text := filters.text

enamldef Optimizer(Form):
    attr experiment
    attr analysis

    Label:
        text = 'enable'
    CheckBox:
        checked := analysis.enable

    Label:
        text='update method'
    ComboBox:
        items = ['Nelder-Mead','genetic','gradient descent','weighted Nelder-Mead']
        index := analysis.optimization_method

    Label:
        text='Initial Step (fraction)'
    FloatField:
        value := analysis.initial_step

    Label:
        text='End when step size is less than (fraction) on all axes'
    FloatField:
        value := analysis.end_condition_step_size

    Label:
        text='cost function'
    MultilineField:
        constraints=[height==300]
        text:=experiment.optimizer.cost_function

    MPLCanvas: canvas:
        constraints = [(height==3000)|'strong',(width==1000)|'strong']
        hug_width = 'ignore'
        figure << analysis.figure

def Picomotor(HGroup):
    attr motor

    Label:
        text = 'serial number'
    Field:
        text := motor.serial_number
    Label:
        text = 'motor number'
    Field:
        text := motor.motor_number
    Label:
        text := position
    EvalProp:
        prop << motor.desired_position

def Picomotors(Container):
    attr picomotors

    HGroup:
        Label:
            text = 'enable'
        CheckBox:
            checked := picomotors.enable
        Label:
            text = 'IP Address'
        Field:
            text := picomotors.IP
        Label:
            text = 'port'
        IntField:
            value := picomotors.port
    Looper:
        iterable << picomotors.motors
        Picomotor:
            motor << loop_item

def loadIcon():
    #create icon
    with open(os.path.join('icons','2013_11_14_15_18_54_retention_PCA_filtered_image_rotated_smoothed.png'), 'rb') as f:
        data = f.read()
    image = Image(data=data)
    icon = Icon(images=[IconImage(image=image)])
    return icon

enamldef Main(MainWindow): main:
    attr experiment
    
    title='Saffmanlab experiment controller'
    initial_position=(0,0)
    initial_size=(1500,1100)
    icon = loadIcon()

    MyStyleSheet:
        #just implement the style sheet defined separately
        pass
    CsMenuBar:
        experiment=main.experiment
        mainWindow=main
    StatusBar:
        StatusItem:
            Label:
                text << 'Status: {}, Iteration: {}, Measurement: {}, Good Measurements: {}, Progress: {}%'.format(experiment.statusStr,experiment.iterationStr,experiment.measurementStr,experiment.goodMeasurementsStr,experiment.progressGUI)
        StatusItem:
            ProgressBar: progress:
                #constraints=[width==1200]
                minimum=0
                maximum=100
                value<<int(experiment.progressGUI)
    Container:
        padding = 0
        ScrollArea:
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'
                hug_height='strong'
                hug_width='strong'
                Notebook: notebook:
                    tabs_closable=False
                    tabs_movable=False
                    tab_style = 'preferences'
                    ExperimentPage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        experiment = main.experiment
                    VariablesPage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        experiment = main.experiment
                    Page:
                        title = 'Report'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        Reports:
                            experiment = main.experiment
                    LabViewPage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        LabView=main.experiment.LabView
                    HSDIO_DigitalOutPage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        HSDIO=main.experiment.LabView.HSDIO
                    #HSDIO_DigitalOutPage:
                    #    style_class << 'valid' if experiment.valid else 'invalid'
                    #    HSDIO=main.experiment.LabView.HSDIO2
                    Page:
                        title='Waveforms'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        Waveforms:
                            HSDIO=main.experiment.LabView.HSDIO
                    DAQmxDigitalOutPage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        DAQmx=main.experiment.LabView.DAQmxDO
                    Page:
                        title = 'DDS'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        DDS_Page:
                            DDS=main.experiment.LabView.DDS
                    RFGenPage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        LabView=main.experiment.LabView
                    CameraPage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        camera=main.experiment.LabView.camera
                    #CounterPage:
                    #    style_class << 'valid' if experiment.valid else 'invalid'
                    #    pass
                    AnalogOutputPage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        AO=main.experiment.LabView.AnalogOutput
                    #Page:
                    #    style_class << 'valid' if experiment.valid else 'invalid'
                    #    title = 'Analog Input'
                    #    AnalogInput:
                    #        AI = main.experiment.LabView.AnalogInput
                    #Page:
                    #    style_class << 'valid' if experiment.valid else 'invalid'
                    #    title = 'Arroyo'
                    #    Arroyo:
                    #        Arroyo = main.experiment.Arroyo
                    PI_PiezoPage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        piezo=main.experiment.LabView.piezo
                    Page:
                        title = 'Picomotors'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        Picomotors:
                            picomotors=main.experiment.picomotors
                    MultiImagePage:
                        style_class << 'valid' if experiment.valid else 'invalid'
                        experiment=main.experiment
                        analysis0=main.experiment.recent_shot_analysis
                        analysis1=main.experiment.shotBrowserAnalysis
                        analysis2=main.experiment.imageSumAnalysis
                        analysis3=main.experiment.text_analysis
                    Page:
                        title = 'Square ROI'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        SquareROIContainer:
                            experiment=main.experiment
                            analysis=main.experiment.squareROIAnalysis
                    Page:
                        title = 'Gaussian ROI'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        GaussianROI:
                            analysis=main.experiment.gaussian_roi
                    Page:
                        title = 'Histogram'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        Histogram:
                            experiment=main.experiment
                            analysis=main.experiment.histogramAnalysis
                    Page:
                        title = 'Histogram Grid'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        HistogramGrid:
                            experiment=main.experiment
                            analysis=main.experiment.histogram_grid
                    Page:
                        title = 'Measurements Graph'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        MeasurementsGraph:
                           experiment=main.experiment
                           analysis=main.experiment.measurements_graph
                    Page:
                        title = 'Iterations Graph'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        IterationsGraph:
                            experiment=main.experiment
                            analysis=main.experiment.iterations_graph
                    Page:
                        title = 'Retention Graph'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        RetentionGraph:
                            experiment=main.experiment
                            analysis=main.experiment.retention_graph
                    Page:
                        title='Filters'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        Container:
                            TTL_filters:
                                instrument = main.experiment.LabView.TTL
                                filters = main.experiment.TTL_filters
                            LoadingFilters:
                                filters = main.experiment.loading_filters
                            FirstMeasurementsFilter:
                                filters = main.experiment.first_measurements_filter
                    Page:
                        title='Optimization'
                        style_class << 'valid' if experiment.valid else 'invalid'
                        Optimizer:
                            experiment=main.experiment
                            analysis=main.experiment.optimizer
